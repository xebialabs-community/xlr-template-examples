# Exported from:        http://host.docker.internal:5516/
# Release version:      23.1.0-rc.2
# Date created:         Mon Oct 30 19:43:01 UTC 2023

---
apiVersion: xl-release/v1
kind: Templates
metadata:
  home: Governance Pipeline
spec:
- template: GovernancePipelineExample-1
  description: "** This template is an example of release governance for a financial institution"
  scheduledStartDate: 2018-03-08T14:00:00Z
  phases:
  - phase: construct_pipeline
    tasks:
    - name: Populate template variables
      type: xlrelease.SequentialGroup
      precondition: "releaseVariables['releaseConfigFileRepoLocation']  != ''"
      tasks:
      - name: Set repository variables
        type: xlrelease.ScriptTask
        script: |-
          releaseconfig_file = releaseVariables['releaseConfigFileRepoLocation'].strip()
          if '@' in releaseconfig_file:
              try:
                  project_name,repo_name,branch_name,file_name = releaseconfig_file.split('@')
              except ValueError:
                  print "releaseConfigFileRepoLocation not specified correctly - Format SPK@repo_name@branch_name"

          releaseVariables['release_config_file_repo_url'] = "projects/" + project_name + "/repos/"   +  repo_name + "/raw/" + file_name + "?at=refs/heads/" +  branch_name
          repo_user = "code-" + project_name + "-" + repo_name + "-user"
          releaseVariables['repo_user'] = repo_user.lower()

          print releaseVariables['release_config_file_repo_url'] + " Bitbucket ReleaseConfig File Repo URL"

          for env in ${releaseEnvironments}:
              releaseVariables['temp_integrated_release_environment'].append(env)
      - name: Get Release File
        type: xlrelease.Task
        flagStatus: ATTENTION_NEEDED
        flagComment: Task 'Get Release File' in Phase 'construct_pipeline' has been
          replaced by a manual task. The task of type 'appldesc.GetFile' could not
          be found because of a missing plugin.
        variableMapping:
          pythonScript.password: "${global.repo_password}"
          pythonScript.fileContent: "${release_config_file_content}"
      - name: Update Variables
        type: xlrelease.ScriptTask
        script: |-
          import json

          releaseConfigData = releaseVariables['release_config_file_content']

          jsonData = json.loads(releaseConfigData)

          component= jsonData['component']
          phases = jsonData['phases']
          environments = jsonData['environments']


          releaseEnvironments = jsonData['component']['releaseEnvironments']

          #jiraEnableStatusUpdates
          jiraEnableStatusUpdates = "Yes" if jsonData['component']['jiraEnableStatusUpdates'] else "No"

          #remedyEnableIntegration
          remedyEnableIntegration = "Yes" if jsonData['component']['remedyEnableIntegration'] else "No"

          # Env Name to type mapping.
          phaseType = {}

          # sonarEnableMetricsCheckMapping
          sonarEnableMetricsCheck = {}

          #towerJobTemplateMapping
          towerJobTemplate = {}

          #towerInventory
          towerInventory = {}

          #litmusEnableFunctionalTests
          litmusEnableFunctionalTests = {}

          #litmusComponentName
          litmusComponentName = {}

          #litmusTargetApplicationUrl
          litmusTargetApplicationUrl = {}

          #phaseEnablePreDeployGate_dev
          phaseEnablePreDeployGate_dev = ''

          #phaseEnablePreDeployGate_lle
          phaseEnablePreDeployGate_lle = ''

          #phaseEnablePostDeployGate_dev
          phaseEnablePostDeployGate_dev = ''

          #phaseEnablePostDeployGate_lle
          phaseEnablePostDeployGate_lle = ''

          #release_notification_list
          phaseNotificationDg_dev = ''

          phaseNotificationDg_lle = ''

          phaseNotificationDg_prod = ''

          for relEnv in releaseEnvironments:
              for env in environments:
                  if env['environmentName'] == relEnv:
                      phaseType[relEnv] = env['phaseType'].strip()
                      sonarEnableMetricsCheck[relEnv]= "Yes" if env['sonarEnableMetricsCheck'] else "No"
                      towerJobTemplate[relEnv] = env['towerJobTemplate'].strip()
                      towerInventory[relEnv] = env['towerInventory'].strip()
                      litmusEnableFunctionalTests[relEnv] = "Yes" if env['litmusEnableFunctionalTests'] else "No"
                      litmusComponentName[relEnv] = env['litmusComponentName'].strip()
                      litmusTargetApplicationUrl[relEnv] = env['litmusTargetApplicationUrl'].strip()
                  for phase in phases:
                      if phase['phaseType'] == env['phaseType']:
                          if phase['phaseType'] == "DEV":
                              phaseEnablePreDeployGate_dev = "Yes" if phase['phaseEnablePreDeployGate'] else "No"
                              phaseEnablePostDeployGate_dev = "Yes" if phase['phaseEnablePostDeployGate'] else "No"
                              phaseNotificationDg_dev = phase['phaseNotificationDg']
                          if phase['phaseType'] == "LLE":
                              phaseEnablePreDeployGate_lle = "Yes" if phase['phaseEnablePreDeployGate'] else "No"
                              phaseEnablePostDeployGate_lle = "Yes" if phase['phaseEnablePostDeployGate'] else "No"
                              phaseNotificationDg_lle = phase['phaseNotificationDg']
                          if phase['phaseType'] == "PROD":
                              phaseNotificationDg_prod = phase['phaseNotificationDg']



          vars = getCurrentRelease().getVariables()

          for var in vars:
              if var.key == "sonarEnableMetricsCheck":
                  var.setValue(sonarEnableMetricsCheck)
                  releaseApi.updateVariable(var)
              if var.key == "towerJobTemplate":
                  var.setValue(towerJobTemplate)
                  releaseApi.updateVariable(var)
              if var.key == "phaseType":
                  var.setValue(phaseType)
                  releaseApi.updateVariable(var)
              if var.key == "towerInventory":
                  var.setValue(towerInventory)
                  releaseApi.updateVariable(var)
              if var.key == "litmusEnableFunctionalTests":
                  var.setValue(litmusEnableFunctionalTests)
                  releaseApi.updateVariable(var)
              if var.key == "litmusComponentName":
                  var.setValue(litmusComponentName)
                  releaseApi.updateVariable(var)
              if var.key == "litmusTargetApplicationUrl":
                  var.setValue(litmusTargetApplicationUrl)
                  releaseApi.updateVariable(var)
              if var.key == "phaseEnablePreDeployGate_dev":
                  var.setValue(phaseEnablePreDeployGate_dev)
                  releaseApi.updateVariable(var)
              if var.key == "phaseEnablePostDeployGate_dev":
                  var.setValue(phaseEnablePostDeployGate_dev)
                  releaseApi.updateVariable(var)
              if var.key == "phaseNotificationDg_dev":
                  var.setValue(phaseNotificationDg_dev)
                  releaseApi.updateVariable(var)
              if var.key == "phaseEnablePreDeployGate_lle":
                  var.setValue(phaseEnablePreDeployGate_lle)
                  releaseApi.updateVariable(var)
              if var.key == "phaseEnablePostDeployGate_lle":
                  var.setValue(phaseEnablePostDeployGate_lle)
                  releaseApi.updateVariable(var)
              if var.key == "phaseNotificationDg_lle":
                  var.setValue(phaseNotificationDg_lle)
                  releaseApi.updateVariable(var)
              if var.key == "phaseNotificationDg_prod":
                  var.setValue(phaseNotificationDg_prod)
                  releaseApi.updateVariable(var)
              if var.key == "releaseEnvironments":
                  var.setValue(releaseEnvironments)
                  releaseApi.updateVariable(var)
              if var.key == "jiraEnableStatusUpdates":
                  var.setValue(jiraEnableStatusUpdates)
                  releaseApi.updateVariable(var)
              if var.key == "remedyEnableIntegration":
                  var.setValue(remedyEnableIntegration)
                  releaseApi.updateVariable(var)
              for elem in component:
                  if elem not in ("jiraEnableStatusUpdates","remedyEnableIntegration") and var.key == elem:
                      var.setValue(jsonData['component'][elem])
                      releaseApi.updateVariable(var)

              # Update Template variables.

          templateId = getCurrentRelease().getOriginTemplateId()
          templateVars = templateApi.getVariables(templateId)

          for var in templateVars:
              if var.key == "sonarEnableMetricsCheck":
                  var.setValue(sonarEnableMetricsCheck)
                  releaseApi.updateVariable(var)
              if var.key == "towerJobTemplate":
                  var.setValue(towerJobTemplate)
                  releaseApi.updateVariable(var)
              if var.key == "phaseType":
                  var.setValue(phaseType)
                  releaseApi.updateVariable(var)
              if var.key == "towerInventory":
                  var.setValue(towerInventory)
                  releaseApi.updateVariable(var)
              if var.key == "litmusEnableFunctionalTests":
                  var.setValue(litmusEnableFunctionalTests)
                  releaseApi.updateVariable(var)
              if var.key == "litmusComponentName":
                  var.setValue(litmusComponentName)
                  releaseApi.updateVariable(var)
              if var.key == "litmusTargetApplicationUrl":
                  var.setValue(litmusTargetApplicationUrl)
                  releaseApi.updateVariable(var)
              if var.key == "phaseEnablePreDeployGate_dev":
                  var.setValue(phaseEnablePreDeployGate_dev)
                  releaseApi.updateVariable(var)
              if var.key == "phaseEnablePostDeployGate_dev":
                  var.setValue(phaseEnablePostDeployGate_dev)
                  releaseApi.updateVariable(var)
              if var.key == "phaseNotificationDg_dev":
                  var.setValue(phaseNotificationDg_dev)
                  releaseApi.updateVariable(var)
              if var.key == "phaseEnablePreDeployGate_lle":
                  var.setValue(phaseEnablePreDeployGate_lle)
                  releaseApi.updateVariable(var)
              if var.key == "phaseEnablePostDeployGate_lle":
                  var.setValue(phaseEnablePostDeployGate_lle)
                  releaseApi.updateVariable(var)
              if var.key == "phaseNotificationDg_lle":
                  var.setValue(phaseNotificationDg_lle)
                  releaseApi.updateVariable(var)
              if var.key == "phaseNotificationDg_prod":
                  var.setValue(phaseNotificationDg_prod)
                  releaseApi.updateVariable(var)
              if var.key == "releaseEnvironments":
                  var.setValue(releaseEnvironments)
                  releaseApi.updateVariable(var)
              if var.key == "jiraEnableStatusUpdates":
                  var.setValue(jiraEnableStatusUpdates)
                  releaseApi.updateVariable(var)
              if var.key == "remedyEnableIntegration":
                  var.setValue(remedyEnableIntegration)
                  releaseApi.updateVariable(var)
              for elem in component:
                  if elem not in ("jiraEnableStatusUpdates","remedyEnableIntegration") and var.key == elem:
                      var.setValue(jsonData['component'][elem])
                      releaseApi.updateVariable(var)
    - name: Update release name
      type: xlrelease.ScriptTask
      script: |-
        build_name="${artifactoryBuildName}".replace(" ","")
        myList=build_name.split("::")

        current_release = getCurrentRelease()

        spkName=myList[0]
        comp_name=myList[1]
        scm_branch=myList[2]

        for i in range(3, len(myList)):
             scm_branch = scm_branch+"/"+ myList[i]

        if "Integrated" in "${integrated_release_name}":
            current_release.title = "{0} - {1} {2}({3})".format("${integrated_release_name}",spkName,comp_name,scm_branch)
        else:
            current_release.title = "{0} {1}({2})".format(spkName,comp_name,scm_branch)

        releaseApi.updateRelease(current_release)

        releaseVariables['original_release_title']=current_release.title

        if ("${jenkinsBuildNo}"):
            current_release.title = "{0} Build#{1}".format(current_release.title,"${jenkinsBuildNo}")

        releaseApi.updateRelease(current_release)

        releaseVariables["release_candidate_name"]=scm_branch.replace("/","-")
    - name: Set integrated release variables
      type: xlrelease.ScriptTask
      precondition: getCurrentRelease().title.startswith("Integrated")
      script: |-
        current_release = getCurrentRelease()
        if current_release.title.startswith("Integrated"):
            releaseVariables['phaseEnablePreDeployGate_dev'] = "No"
            releaseVariables['phaseEnablePostDeployGate_dev'] = "No"
            releaseVariables['phaseEnablePreDeployGate_lle'] = "No"
            releaseVariables['phaseEnablePostDeployGate_lle'] = "No"
            if "${releaseConfigFileRepoLocation}"  != '':
                releaseVariables['releaseEnvironments'].clear()
                for env in ${temp_integrated_release_environment}:
                    releaseVariables['releaseEnvironments'].append(env)
    - name: "${jenkinsTriggerInfo} Generate phases and tasks of the pipeline"
      type: xlrelease.ScriptTask
      script: |-
        # Validating the artifactory repository value
        if 'staging' in "${artifactoryBuildRepo}".lower():
            print "\n"
            print "**The entered artifactory repository detail is not a release repository. Please enter the valid one**"
            print "\n"
            sys.exit(1)
        elif 'snapshot' in "${artifactoryBuildRepo}".lower():
            print "\n"
            print "**The entered artifactory repository details is not a release repository. Please enter the valid one**"
            print "\n"
            sys.exit(1)

        current_release = getCurrentRelease()
        spkName = "${spkName}"
        lobName = "${lobName}"
        release_tags = [spkName,lobName]
        current_release.tags = release_tags
        release_owner = current_release.owner
        release_name=current_release.title
        releaseVariables['xlr_remedy_workinfo_workLogSubmitter'] = release_owner
        releaseVariables['xlr_remedy_workinfo_creator'] = release_owner
        releaseVariables["release_owner"]=release_owner
        releaseVariables["jira_fixversion"]=release_name
        releaseVariables["jira_project"]=spkName
        releaseVariables["litmus_spk"]=spkName
        releaseVariables["artifact_build_name_url_format"]="${artifactoryBuildName}".replace(" ", "%20")


        thisReleaseId = '${release.id}'
        if thisReleaseId :
            id = thisReleaseId.replace('/','-').replace("Applications-","/#/releases/")
            releaseVariables['delivery_pipeline_url'] = "${global.xlrurl}"+id

        dev_template_phase_title = "phase_template_dev"
        phase_insert_location = int(2)
        dev_template_phase = phaseApi.searchPhases(dev_template_phase_title,current_release.id,None)[0]

        lle_template_phase_title = "phase_template_lle"
        phase_insert_location = int(2)
        lle_template_phase = phaseApi.searchPhases(lle_template_phase_title,current_release.id,None)[0]

        prod_template_phase_title = "phase_template_prod"
        phase_insert_location = int(2)
        prod_template_phase = phaseApi.searchPhases(prod_template_phase_title,current_release.id,None)[0]

        for release_environment_name in ${releaseEnvironments} :
            for component_name in ${spkComponentsToRelease}:
                new_phase_title = release_environment_name + "(" + component_name + ")"
                delivery_environment_type = ${phaseType}[release_environment_name]
                if delivery_environment_type == "DEV":
                    copied_phase = phaseApi.copyPhase(dev_template_phase.id,phase_insert_location)
                elif delivery_environment_type == "LLE":
                    copied_phase = phaseApi.copyPhase(lle_template_phase.id,phase_insert_location)
                elif delivery_environment_type == "PROD":
                     copied_phase = phaseApi.copyPhase(prod_template_phase.id,phase_insert_location)
                else:
                    print "Do nothing"
                copied_phase.title = new_phase_title
                phaseApi.updatePhase(copied_phase)
                phase_insert_location = phase_insert_location + 1

        # Delete the Template Phase
        phaseApi.deletePhase(dev_template_phase.id)
        phaseApi.deletePhase(lle_template_phase.id)
        phaseApi.deletePhase(prod_template_phase.id)

        # Update release
        releaseApi.updateRelease(current_release)
    color: '#0099CC'
  - phase: phase_template_dev
    tasks:
    - name: Set template phase details
      type: xlrelease.ScriptTask
      tags:
      - key_process_step
      script: |-
        current_phase = getCurrentPhase()

        current_phase_title_asis = current_phase.title
        current_phase_title_split = current_phase_title_asis.split('(')
        delivery_environment_name = current_phase_title_split[0]
        component_name_split = current_phase_title_split[1].split(')')
        component_name = component_name_split[0]

        releaseVariables['component_name'] = component_name
        releaseVariables['delivery_environment_name'] = delivery_environment_name
        releaseVariables['delivery_environment_type'] = ${phaseType}[delivery_environment_name]
        releaseVariables['enable_sonar_metrics_check'] = ${sonarEnableMetricsCheck}[delivery_environment_name]
        releaseVariables['ansible_tower_job_template_name'] = ${towerJobTemplate}[delivery_environment_name]
        #for DMZ integration
        releaseVariables['xlr_inventory_name'] = ${towerInventory}[delivery_environment_name]

        if delivery_environment_name in ${litmus_env_to_phase_mapping}:
            releaseVariables['litmus_phase'] = ${litmus_env_to_phase_mapping}[delivery_environment_name]
        if delivery_environment_name in ${litmusComponentName}:
            releaseVariables['litmus_test_component'] = ${litmusComponentName}[delivery_environment_name]
        if delivery_environment_name in ${litmus_env_to_app_url_mapping}:
            releaseVariables['litmus_app_url'] = ${litmus_env_to_app_url_mapping}[delivery_environment_name]
        if delivery_environment_name in ${litmusEnableFunctionalTests}:
            releaseVariables['litmus_enable_automated_tests'] = ${litmusEnableFunctionalTests}[delivery_environment_name].strip().lower()
        if delivery_environment_name in ${litmusTargetApplicationUrl}:
            releaseVariables['litmus_test_url'] = ${litmusTargetApplicationUrl}[delivery_environment_name]

        if releaseVariables['delivery_environment_type'] == 'DEV':
            releaseVariables['release_notification_list'] = "${phaseNotificationDg_dev}"
        elif releaseVariables['delivery_environment_type'] == 'LLE':
            releaseVariables['release_notification_list'] = "${phaseNotificationDg_lle}"
        elif releaseVariables['delivery_environment_type'] == 'PROD':
            releaseVariables['release_notification_list'] = "${phaseNotificationDg_prod}"
        else:
             releaseVariables['release_notification_list'] = "please_configure_some_email@domain.com"

        phase_certified_artifact_version_name="phase_certified_artifact_version"+str(component_name)
        phase_certified_artifact_property_name="phase_certified_artifact_property"+str(component_name)

        try:
            releaseVariables['phase_certified_artifact_version']=releaseVariables[phase_certified_artifact_version_name]
            releaseVariables['phase_certified_artifact_property']=releaseVariables[phase_certified_artifact_property_name]
        except:
            releaseVariables['phase_certified_artifact_version']=""
            releaseVariables['phase_certified_artifact_property']=""

        ### Set deployer ID and password

        releaseVariables['nonprod_tower_deployer_id'] = ""
        releaseVariables['nonprod_tower_deployer_password'] = ""

        if releaseVariables['towerDeployerIdNonProd']:
              releaseVariables['nonprod_tower_deployer_id'] = releaseVariables['towerDeployerIdNonProd']
              releaseVariables['nonprod_tower_deployer_password'] = releaseVariables['towerDeployerPasswordNonProd']
    - name: Update release name
      type: xlrelease.ScriptTask
      script: |-
        current_release = getCurrentRelease()

        if ("${jenkinsBuildNo}"):
            current_release.title = "{0} Build#{1} {2}".format("${original_release_title}","${jenkinsBuildNo}","${delivery_environment_name}")
        else:
            current_release.title = "{0} {1}".format("${original_release_title}","${delivery_environment_name}")

        releaseApi.updateRelease(current_release)
    - name: Acknowledge/sign off release code quality metrics
      type: xlrelease.SequentialGroup
      precondition: "releaseVariables['enable_sonar_metrics_check'] == 'Yes'"
      tags:
      - key_process_step
      tasks:
      - name: Delete Existing SonarQube token
        type: webhook.JsonWebhook
        URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
        method: POST
        username: "${global.cross_connect_userid}"
        variableMapping:
          pythonScript.password: "${global.cross_connect_password}"
      - name: Generate SonarQube token
        type: webhook.JsonWebhook
        URL: "${global.sonarurl}/api/user_tokens/generate?name=${spkComponentsToRelease}"
        method: POST
        username: "${global.cross_connect_userid}"
        jsonPathExpression: $.token
        variableMapping:
          pythonScript.result: "${SonarQube_token}"
          pythonScript.password: "${global.cross_connect_password}"
      - name: "Reading SonarQube Metrics for  ${sonarComponentKey}"
        type: xlrelease.ScriptTask
        script: |-
          import urllib2
          import json
          import base64

          # defining the api-endpoint

          url="${global.sonarurl}/api/measures/component?componentKey=${sonarComponentKey}&metricKeys=alert_status,bugs,blocker_violations,critical_violations,vulnerabilities,code_smells,duplicated_blocks,duplicated_lines_density,ncloc"

          print("URL....", url)

          token = releaseVariables['SonarQube_token'] + ":"
          encodedToken =  base64.encodestring(token).rstrip('\n')
          print ("Encodedtoken= ", encodedToken)

          req=urllib2.Request(url=url)
          req.add_header('Authorization', "Basic %s" % encodedToken)
          req.add_header("Content-Type", "application/json")

          jobResponse=urllib2.urlopen(req).read()

          print("JOB Response", jobResponse)

          json_data = json.loads(jobResponse)

          print ("\n JSON DATA....",json_data)

          metrics_data = {}
          for item in json_data['component']['measures']:
              metrics_data[item['metric']] = item['value']

          releaseVariables['sonarqube_bugs']  = int(metrics_data.get('bugs'))

          releaseVariables['sonarqube_blocker_violations']  = int(metrics_data.get('blocker_violations'))

          releaseVariables['sonarqube_critical_violations']  = int(metrics_data.get('critical_violations'))
          releaseVariables['sonarqube_vulnerabilities'] = int(metrics_data.get('vulnerabilities'))
          releaseVariables['sonarqube_code_smells'] = int(metrics_data.get('code_smells'))
          releaseVariables['sonarqube_duplicated_blocks'] = int(metrics_data.get('duplicated_blocks'))
          releaseVariables['sonarqube_duplicated_lines_density'] = metrics_data.get('duplicated_lines_density')
          releaseVariables['sonarqube_ncloc'] = int(metrics_data.get('ncloc'))

          gg = metrics_data.get('alert_status')

          if gg == "OK":
              releaseVariables['sonarqube_quality_gate'] = "PASSED"

          if gg == "ERROR":
             releaseVariables['sonarqube_quality_gate'] = "FAILED"
      - name: Delete SonarQube token
        type: webhook.JsonWebhook
        URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
        method: POST
        username: "${global.cross_connect_userid}"
        variableMapping:
          pythonScript.password: "${global.cross_connect_password}"
      - name: Sign off on SonarQube metrics for the release
        type: xlrelease.GateTask
        description: |-
          - Quality Gate :  ${sonarqube_quality_gate}
          - Bugs: ${sonarqube_bugs}
          - Blocker Violations: ${sonarqube_blocker_violations}
          - Critical Violations: ${sonarqube_critical_violations}
          - Vulnerabilities: ${sonarqube_vulnerabilities}
          - Code Smells: ${sonarqube_code_smells}
          - Duplicated Blocks: ${sonarqube_duplicated_blocks}
          - Duplicated Line Density: ${sonarqube_duplicated_lines_density}
          - Lines of Code: ${sonarqube_ncloc}
        tags:
        - key_process_step
    - name: Pre-tasks for DMZ deployment
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Validate Inventory configured in tower Job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: $..inventory
        variableMapping:
          pythonScript.result: "${ansible_template_inventory_name}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Get Inventory name from Tower Job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].summary_fields.inventory.name"
        precondition: "releaseVariables['ansible_template_inventory_name']!=\"[null]\""
        variableMapping:
          pythonScript.result: "${tower_job_inventory_name}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Validate inventory
        type: xlrelease.ScriptTask
        script: |-
          if releaseVariables['ansible_template_inventory_name']!='[null]' and releaseVariables['xlr_inventory_name']!="":
              if releaseVariables['tower_job_inventory_name'] == releaseVariables['xlr_inventory_name']:
                  print "Inventory name in XLR and Tower are same, Good to go!"
              elif releaseVariables['tower_job_inventory_name'] != releaseVariables['xlr_inventory_name']:
                 print "Ansible tower job_template '${ansible_tower_job_template_name}' is not correctly configured to accept an inventory as input, please update the tower job_template with ('prompt on launch')"
                 sys.exit(1)
          elif releaseVariables['ansible_template_inventory_name']=='[null]' and releaseVariables['xlr_inventory_name']=="":
              print "Ansible tower job_template '${ansible_tower_job_template_name}'is not configured with an inventory name, please configure valid inventory name"
              sys.exit(1)
          print "Validation looks Good !"
      - name: Construct Instance group url  from ansible Job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].related.instance_groups"
        variableMapping:
          pythonScript.password: "${nonprod_tower_deployer_password}"
          pythonScript.result: "${ansible_tower_job_template_instance_group_url}"
      - name: Get Instance group details from instance group url
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}${ansible_tower_job_template_instance_group_url}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: results
        variableMapping:
          pythonScript.result: "${ansible_tower_instance_group_from_template}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Get Ansible inventory id from XLR template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/inventories?name=${xlr_inventory_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].id"
        precondition: "releaseVariables['xlr_inventory_name'] !=\"\""
        variableMapping:
          pythonScript.result: "${ansible_tower_job_inventory}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Get Inventory id from ansible job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].summary_fields.inventory.id"
        precondition: "releaseVariables['xlr_inventory_name'] ==\"\""
        variableMapping:
          pythonScript.result: "${ansible_tower_job_inventory}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Get Ansible Instance group from inventory id
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/inventories/${ansible_tower_job_inventory}/instance_groups"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: results
        variableMapping:
          pythonScript.password: "${nonprod_tower_deployer_password}"
          pythonScript.result: "${ansible_tower_instance_group}"
      - name: "Determine Artifactory: DMZ or Baronet"
        type: xlrelease.ScriptTask
        script: |-
          releaseVariables['deployDMZ_dev']="No"
          releaseVariables['ansible_tower_job_inventory_id']=0
          jobtemplate_deploydmz ="No"
          inventory_deploydmz = "No"
          instance_group_match ="No"
          if releaseVariables['xlr_inventory_name'] =="":
              releaseVariables['ansible_tower_job_inventory_id']=0
          elif releaseVariables['xlr_inventory_name'] !="":
              releaseVariables['ansible_tower_job_inventory_id'] = int (releaseVariables['ansible_tower_job_inventory'])
          print ("Inventory_id passing from XLR to Tower job template =>",releaseVariables['ansible_tower_job_inventory_id'])

          if "ztwr" in releaseVariables['ansible_tower_instance_group']:
              inventory_deploydmz="Yes"
          elif "ztwr" not in releaseVariables['ansible_tower_instance_group']:
              inventory_deploydmz="No"
          if inventory_deploydmz =="No":
              if "ztwr" not in releaseVariables['ansible_tower_instance_group'] and releaseVariables['ansible_tower_instance_group'] !="[]":
                  inventory_instance_grp = "Yes"
              elif releaseVariables['ansible_tower_instance_group'] =="[]":
                  inventory_instance_grp = "No"
              print ("inventory_instance_grp==>", inventory_instance_grp)

          if "ztwr" in releaseVariables['ansible_tower_instance_group_from_template']:
              jobtemplate_deploydmz="Yes"
          elif "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template']:
              jobtemplate_deploydmz = "No"

          if jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="Yes":
              print """Instance group in inventory configured with non-DMZ but instance group in tower job template configured with DMZ \n Always job template instance group take precedence, so please configure your Tower job template properly"""
              sys.exit(1)
          elif jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="No":
              releaseVariables['deployDMZ_dev'] = "Yes"
          elif jobtemplate_deploydmz == "Yes" and inventory_deploydmz=="Yes":
              if "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              elif "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              elif "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              elif "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              if instance_group_match == "Yes":
                  releaseVariables['deployDMZ_dev'] = "Yes"
              else:
                  print """DMZ instance group configured in inventory does not match with DMZ instance group configured in job template...\n Please configure them correctly!!"""
                  sys.exit(1)

          if jobtemplate_deploydmz=="No":
              if "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template'] and releaseVariables['ansible_tower_instance_group_from_template'] !="[]":
                  template_instance_grp = "Yes"
              elif releaseVariables['ansible_tower_instance_group_from_template'] =="[]":
                  template_instance_grp = "No"
              print ("template_instance_grp==>", template_instance_grp)
              if template_instance_grp == "Yes" and inventory_deploydmz=="Yes":
                  print """Your inventory's instance group configured with DMZ But Your job template's instance group not configured with DMZ. \n Always job template instance group take precedence, so please configure your Tower job template properly"""
                  releaseVariables['deployDMZ_dev'] = "No"
                  sys.exit(1)
              elif template_instance_grp == "No" and inventory_deploydmz=="Yes":
                  releaseVariables['deployDMZ_dev'] = "Yes"
              elif template_instance_grp == "No" and inventory_deploydmz=="No":
                  releaseVariables['deployDMZ_dev'] = "No"
          print ("inventory_dmz==>", inventory_deploydmz)
          print ("jobtemplate_dmz==>", jobtemplate_deploydmz)
          print("<-------------------deployDMZ---------->", releaseVariables['deployDMZ_dev'])
    - name: Get build artifact version (s) to deploy
      type: xlrelease.SequentialGroup
      tasks:
      - name: Artifactory API key generation
        type: xlrelease.SequentialGroup
        description: '### This task will generate encrypted API key that can be used
          in the fetch artifact version script tasks of this release template'
        tasks:
        - name: GET
          type: webhook.JsonWebhook
          URL: "${global.artifactoryurl}/api/security/apiKey"
          username: "${global.cross_connect_userid}"
          jsonPathExpression: $.apiKey
          variableMapping:
            pythonScript.result: "${ArtifactoryAPIkey}"
            pythonScript.password: "${global.cross_connect_password}"
      - name: Get build artifact's latest version
        type: xlrelease.ScriptTask
        description: "#### This task will get latest version of the build artifact\
          \  ####"
        script: |-
          import urllib2
          import json

          artifactoryUrl="${global.artifactoryurl}/api/search/aql"

          def getArtifactDetails(repo_name,build_artifact_name):
              data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %(repo_name,build_artifact_name)
              artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
              artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest.add_header("Content-Type", "text/plain")
              artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
              artifactData = json.loads(artifactoryResponse)

              data1="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"path\":{\"$match\":\"%s\"}},{\"name\":{\"$match\":\"%s\"}}).include(\"name\",\"repo\",\"path\",\"created\",\"property\",\"artifact.module.build.url\")" %(repo_name,build_artifact_name,artifactData["results"][0]["path"],artifactData["results"][0]["name"])
              artifactoryRequest1=urllib2.Request(url=artifactoryUrl,data=data1)
              artifactoryRequest1.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest1.add_header("Content-Type", "text/plain")
              jobResponse1=urllib2.urlopen(artifactoryRequest1).read()
              artifactData1 = json.loads(jobResponse1)

              releaseVariables["artifact_build_version_ciurl_var"]=artifactData1["results"][0]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]

              certification_history = ""
              for i in xrange(len(artifactData1["results"][0]["properties"])):
                  if ("Certified" in artifactData1["results"][0]["properties"][i]["key"]):
                      certification_history="\n\n" + artifactData1["results"][0]["properties"][i]["key"] + "=" + artifactData1["results"][0]["properties"][i]["value"]+ "\n\n" + certification_history
                  if (artifactData1["results"][0]["properties"][i]["key"] == "ait.number"):
                      releaseVariables["artifact_build_version_ait_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "scm.location"):
                      releaseVariables["artifact_build_version_scmloc_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "build.number"):
                      releaseVariables["artifact_build_version_buildnum_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "scm.branch"):
                      releaseVariables["artifact_build_version_scmbranch_var"]=artifactData1["results"][0]["properties"][i]["value"]

              releaseVariables["artifactory_certification_history"]=certification_history

              data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %(repo_name,build_artifact_name,releaseVariables["artifact_build_version_buildnum_var"])
              artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
              artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest2.add_header("Content-Type", "text/plain")
              jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
              artifactData2 = json.loads(jobResponse2)

              mylist=""
              for index in range(len(artifactData2["results"])):
                  artifact_build_version_var="artifact_build_version_var_"+str(index)
                  releaseVariables[artifact_build_version_var]=artifactData2["results"][index]["name"]
                  data_url="${global.artifactoryurl}"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                  if(mylist==""):
                      mylist=data_url
                  else:
                      mylist=mylist+","+data_url

              if ',' in mylist:
                  mylist=mylist.replace(",","', '")
                  mylist= "['"+mylist+"']"

              releaseVariables["artifact_build_version_artifactoryUrl"] = mylist



          getArtifactDetails("${artifactoryBuildRepo}","${artifactoryBuildName}")

          releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"
          releaseVariables["old_artifact_build_version_artifactoryUrl"]=releaseVariables["artifact_build_version_artifactoryUrl"]
          releaseVariables["old_artifact_build_version_buildnum_var"]=releaseVariables["artifact_build_version_buildnum_var"]
    - name: Deployment approval by Deployer DEV team
      type: xlrelease.UserInputTask
      description: |-
        #### Hello Deployer ${delivery_environment_type} Team :-
        ${phase_certified_artifact_property} ${phase_certified_artifact_version}

        Tower job template ${ansible_tower_job_template_name} will deploy the following build to ${delivery_environment_name}

        ${artifact_build_version_artifactorybrowseUrl}

        Certification History:
        ${artifactory_certification_history}

        Click "Complete" to to kick off deployment job in tower
      precondition: "\"${phaseEnablePreDeployGate_dev}\".lower() == \"yes\""
      tags:
      - key_process_step
      variables:
      - artifact_build_version_artifactoryUrl
      - artifact_build_version_buildnum_var
      - nonprod_tower_deployer_id
      - nonprod_tower_deployer_password
    - name: Deploy application changes/build
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Construct artifactory url for deployment
        type: xlrelease.ScriptTask
        description: "#### This task will get latest version of the build artifact\
          \  ####"
        script: |-
          import urllib2
          import json

          artifactoryUrl="${global.artifactoryurl}/api/search/aql"
          myNewUrl="${artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
          myNewUrl=myNewUrl.replace("webapp/#/artifacts/browse/tree/General/","")
          myNewUrl=myNewUrl.replace("${artifactoryBuildRepo}/","")
          myNewUrl=myNewUrl.replace("[","")
          myNewUrl=myNewUrl.replace("]","")
          myNewUrl=myNewUrl.replace("'","")
          myNewUrlList=myNewUrl.split(",")


          myOldUrl="${old_artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
          myOldUrl=myOldUrl.replace("webapp/#/artifacts/browse/tree/General/","")
          myOldUrl=myOldUrl.replace("${artifactoryBuildRepo}/","")
          myOldUrl=myOldUrl.replace("[","")
          myOldUrl=myOldUrl.replace("]","")
          myOldUrl=myOldUrl.replace("'","")
          myOldUrlList=myOldUrl.split(",")


          def GetFinalArtifactUrlList(buildNumber):
              data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %("${artifactoryBuildRepo}","${artifactoryBuildName}",buildNumber)
              artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
              artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest2.add_header("Content-Type", "text/plain")
              jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
              artifactData2 = json.loads(jobResponse2)

              mylist=""
              for index in range(len(artifactData2["results"])):
                  artifact_build_version_var="artifact_build_version_var_"+str(index)
                  releaseVariables[artifact_build_version_var]=artifactData2["results"][index]["name"]
                  data_url="${global.artifactoryurl}"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                  if(mylist==""):
                      mylist=data_url
                  else:
                      mylist=mylist+","+data_url

              if ',' in mylist:
                  mylist=mylist.replace(",","', '")
                  mylist= "['"+mylist+"']"

              releaseVariables["artifact_build_version_artifactoryUrl"] = mylist
              releaseVariables["artifact_build_version_path_var"]=artifactData2["results"][index]["path"]
              releaseVariables["artifact_build_version_name_var"]=artifactData2["results"][index]["name"]

          def GetFinalArtifactData(myPathName,myArtifactName):
              data1="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"path\":{\"$match\":\"%s\"}},{\"name\":{\"$match\":\"%s\"}}).include(\"name\",\"repo\",\"path\",\"created\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",myPathName,myArtifactName)
              artifactoryRequest1=urllib2.Request(url=artifactoryUrl,data=data1)
              artifactoryRequest1.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest1.add_header("Content-Type", "text/plain")
              jobResponse1=urllib2.urlopen(artifactoryRequest1).read()
              artifactData1 = json.loads(jobResponse1)

              releaseVariables["artifact_build_version_ciurl_var"]=artifactData1["results"][0]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]

              for i in xrange(len(artifactData1["results"][0]["properties"])):
                  if (artifactData1["results"][0]["properties"][i]["key"] == "ait.number"):
                      releaseVariables["artifact_build_version_ait_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "scm.location"):
                      releaseVariables["artifact_build_version_scmloc_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "build.number"):
                      releaseVariables["artifact_build_version_buildnum_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "scm.branch"):
                      releaseVariables["artifact_build_version_scmbranch_var"]=artifactData1["results"][0]["properties"][i]["value"]

          if "${old_artifact_build_version_buildnum_var}" != "${artifact_build_version_buildnum_var}":
              GetFinalArtifactUrlList("${artifact_build_version_buildnum_var}")
              GetFinalArtifactData(releaseVariables["artifact_build_version_path_var"],releaseVariables["artifact_build_version_name_var"])
          elif myNewUrlList[0] not in myOldUrlList:
              myNewUrl=myNewUrlList[0].rsplit('/', 1)
              GetFinalArtifactData(myNewUrl[0],myNewUrl[1])

          releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"


          ### Set Deployment Dashboard parameters

          spkName = "${spkName}".upper().strip()
          delivery_environment_name = "${delivery_environment_name}".upper().strip()
          dashboard_delivery_environment_name = spkName + "-" + delivery_environment_name
          releaseVariables['dashboard_delivery_environment_name'] = dashboard_delivery_environment_name

          # ID
          dashboard_deployerId = str(dashboard_delivery_environment_name) + "-deployerId"
          releaseVariables[dashboard_deployerId] = "${nonprod_tower_deployer_id}"

          ###XLR DMZ Integration
          if releaseVariables['deployDMZ_dev']=="Yes":
                  releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl'].replace("${global.artifactoryurl}","${global.dmzArtifactoryUrl_NonProd}")
          else:
              releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl']
          print("deployDMZ_dev==", releaseVariables['deployDMZ_dev'])
          print("Artifactory URL==", releaseVariables['published_artifact_url'])
      - name: Get job template id
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].id"
        variableMapping:
          pythonScript.result: "${ansible_tower_job_template_id}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: "Deploy ${artifactoryBuildName}"
        type: ansible.LaunchJobTemplate
        username: "${nonprod_tower_deployer_id}"
        jobTemplate: "${ansible_tower_job_template_id}"
        description: "## Deploy ${artifactoryBuildName}"
        facets:
        - type: udm.DeploymentTaskFacet
          variableMapping:
            environmentId: "${dashboard_delivery_environment_name}"
            applicationId: "${component_name}"
            version: "${artifact_build_version_buildnum_var}"
        variableMapping:
          pythonScript.jobId: "${ansible_job_id}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
          pythonScript.inventory: "${ansible_tower_job_inventory_id}"
        tags:
        - key_process_step
      - name: Fetch ansible job log
        type: xlrelease.ScriptTask
        description: "#### This task will get latest version of the build artifact\
          \  ####"
        script: "releaseVariables[\"ansible_tower_job_url\"]=\"${global.ansible-non-prod-towerurl}/#/jobs/${ansible_job_id}\""
    - name: Kick off litmus tests
      type: xlrelease.SequentialGroup
      precondition: "\"${litmus_enable_automated_tests}\" == \"yes\""
      tags:
      - key_process_step
      tasks:
      - name: Validate LitmusTest input
        type: xlrelease.ScriptTask
        script: |-
          val = "${artifact_build_version_ait_var}"
          if not val: raise ValueError("ait_number is mandatory parameter for LitmusTest execution.")

          val = "${litmus_test_component}"
          if not val: raise ValueError("litmusComponentName is mandatory parameter for LitmusTest execution. Please fill it with valid value for your environment.")

          val = "${litmus_test_url}"
          if not val: raise ValueError("litmusTargetApplicationUrl is mandatory parameter for LitmusTest execution.Please fill it with valid value for your environment.")

          val = "${litmus_spk}"
          if not val: raise ValueError("litmus_spk is mandatory parameter for LitmusTest execution.")

          releaseVariables['litmus_input_validated'] = True
      - name: Submit Litmus Request
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['litmus_input_validated'] == True"
        script: |-
          import urllib2
          import json
          import datetime
          import sys

          payload = {
            "BuildRunID": "" ,
            "AIT": "${artifact_build_version_ait_var}",
            "SPK": "${litmus_spk}",
            "JobStatus": "New",
            "DeployedDate": str(datetime.datetime.now()),
            "TestPhase": "${litmus_phase}",
            "ApplicationURL": "${litmus_app_url}",
            "EnvironmentName": "${delivery_environment_name}",
            "Component": "${litmus_test_component}",
            "Requestor":"XLR"
          }
          print("Req to be submitted to LitmusTest is - \n")
          print(payload)

          # Send req to Litmus
          data=json.dumps(payload)

          baseURL = "${litmus_test_url}"
          if not baseURL.endswith("/"):
              baseURL = baseURL +"/"
          url = baseURL+"LitmusTest/InsertEvent"

          req=urllib2.Request(url=url ,data=data)
          req.add_header("Content-Type", "application/json")
          response=urllib2.urlopen(req).read()
          message = json.loads(response)
          print("\nResponse received-\n")
          print(message)
          requestStatus = message["requestStatus"]
          releaseVariables['litmus_request_id'] = message["requestId"]
          if requestStatus == "Request has been successfully queued.":
            releaseVariables['req_submitted'] = True
            print("\nRequest has been submitted to LitmusTest with requestId - "+ str(message["requestId"]))
          else:
              print("\nRequest could not be submitted to LitmusTest.\n")
              print (requestStatus)
              print("\n")
              sys.exit(1)
      - name: Process Response
        type: xlrelease.SequentialGroup
        precondition: "releaseVariables['req_submitted'] == True"
        tasks:
        - name: Process Smoke Test Response
          type: xlrelease.ScriptTask
          script: |-
            import json
            import urllib2
            import time
            import sys

            payload = {
                "requestId":${litmus_request_id}
            }

            # Send req to Litmus for status check
            data = json.dumps(payload)
            baseURL = "${litmus_test_url}"
            if not baseURL.endswith("/"):
                baseURL = baseURL + "/"
            url = baseURL + "LitmusTest/GetRequestStatus"

            timePassed = 0
            timeoutOccured = True
            while (timePassed < int(${litmus_smoke_timeout})):
                time.sleep(${litmus_polling_interval})
                timePassed = timePassed + ${litmus_polling_interval}

                req = urllib2.Request(url=url, data=data)
                req.add_header("Content-Type", "application/json")
                response = urllib2.urlopen(req).read()
                message = json.loads(response)

                executingStatus = message["executingStatus"]
                returnCode = message["executingState"]
                index = returnCode.find("(")
                shortCode = returnCode
                if index != -1:
                    shortCode = returnCode[:returnCode.find("(")]
                shortCode = shortCode.lower()

                if (executingStatus == 'Waiting' or executingStatus == 'Smoke Executing'):
                    continue
                print(message)
                print("\n")
                print("\n")
                timeoutOccured = False
                executionDetails = message["executionDetails"]
                if (executingStatus.__contains__("Executing")):
                    if (shortCode == "smoke_pass1"):
                        print("\nSmoke Test passed, Basic Test is scheduled.")
                        releaseVariables['litmus_process_basic'] = True
                    elif (shortCode == "smoke_pass2"):
                        print("\nSmoke Passed, Regression Test is scheduled")
                        releaseVariables['litmus_process_regression'] = True
                    elif (shortCode == "basic_pass"):
                        print("\nBasic Passed, Regression Test is scheduled")
                        releaseVariables['litmus_process_regression'] = True
                    else:
                        print("\nInvalid executing state received.\n")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                    print("\nTest execution summary- ")
                    for eDetail in executionDetails:
                        print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                            eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + eDetail["threshold"])
                elif (executingStatus == 'Complete'):
                    if (shortCode == "request complete"):
                        print("\nRequest has been successfully completed.\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        releaseVariables['litmus_test_passed'] = True
                    elif (shortCode.__contains__("error")):
                        print("\nError occurred.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    elif (shortCode.__contains__("_fail")):
                        print("\nRequest failed.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    else:
                        print("\nInvalid executing state received.\n")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                else:
                    print("\nInvalid executing status received.\n")
                    print(executingStatus)
                    print("\n")
                    sys.exit(1)
                break
            if timeoutOccured:
                print("\nTimeout occurred.\n")
                sys.exit(1)
        - name: Process Basic Test Response
          type: xlrelease.ScriptTask
          precondition: "releaseVariables['litmus_process_basic'] == True"
          script: |-
            import json
            import urllib2
            import time
            import sys

            payload = {
                "requestId":${litmus_request_id}
            }

            # Send req to Litmus for status check
            data = json.dumps(payload)
            baseURL = "${litmus_test_url}"
            if not baseURL.endswith("/"):
                baseURL = baseURL + "/"
            url = baseURL + "LitmusTest/GetRequestStatus"

            timePassed = 0
            timeoutOccured = True
            while (timePassed < int(${litmus_basic_timeout})):
                time.sleep(${litmus_polling_interval})
                timePassed = timePassed + ${litmus_polling_interval}

                req = urllib2.Request(url=url, data=data)
                req.add_header("Content-Type", "application/json")
                response = urllib2.urlopen(req).read()
                message = json.loads(response)
                executingStatus = message["executingStatus"]
                returnCode = message["executingState"]
                index = returnCode.find("(")
                shortCode = returnCode
                if index != -1:
                    shortCode = returnCode[:returnCode.find("(")]
                shortCode = shortCode.lower()

                if (executingStatus == 'Basic Executing'):
                    continue
                print(message)
                print("\n")
                print("\n")
                timeoutOccured = False
                executionDetails = message["executionDetails"]
                if (executingStatus == "Regression Executing"):
                    if (shortCode == "basic_pass"):
                        print("\nBasic Passed, Regression Test is scheduled\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        releaseVariables['litmus_process_regression'] = True
                    else:
                        print("\nInvalid executing state received.\n")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                elif (executingStatus == 'Complete'):
                    if (shortCode == "request complete"):
                        print("\nRequest has been successfully completed.\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        releaseVariables['litmus_test_passed'] = True
                    elif (shortCode.__contains__("error")):
                        print("\nError occurred.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    elif (shortCode.__contains__("_fail")):
                        print("\nRequest failed.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    else:
                        print("\nInvalid executing state received.")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                else:
                    print("\nInvalid executing status received.\n")
                    print(executingStatus)
                    print("\n")
                    sys.exit(1)
                break
            if timeoutOccured:
                print("\nTimeout occurred.\n")
                sys.exit(1)
        - name: Process Regression Test Response
          type: xlrelease.ScriptTask
          precondition: "releaseVariables['litmus_process_regression'] == True"
          script: |-
            import json
            import urllib2
            import time
            import sys

            payload = {
              "requestId":${litmus_request_id}
            }

            # Send req to Litmus for status check
            data = json.dumps(payload)
            baseURL = "${litmus_test_url}"
            if not baseURL.endswith("/"):
                baseURL = baseURL +"/"
            url = baseURL+"LitmusTest/GetRequestStatus"

            timePassed = 0
            timeoutOccured = True
            while (timePassed < int(${litmus_regression_timeout})):
                time.sleep(${litmus_polling_interval})
                timePassed = timePassed+ ${litmus_polling_interval}

                req = urllib2.Request(url=url, data=data)
                req.add_header("Content-Type", "application/json")
                response = urllib2.urlopen(req).read()
                message = json.loads(response)

                executingStatus = message["executingStatus"]
                returnCode = message["executingState"]
                index = returnCode.find("(")
                shortCode = returnCode
                if index != -1:
                    shortCode = returnCode[:returnCode.find("(")]
                shortCode = shortCode.lower()
                if (executingStatus == 'Regression Executing' ):
                    continue
                print(message)
                print("\n")
                print("\n")
                timeoutOccured = False
                executionDetails = message["executionDetails"]
                if(executingStatus == 'Complete'):
                    if(shortCode == "request complete"):
                        print("\nRequest has been successfully completed.\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                        releaseVariables['litmus_test_passed'] = True
                    elif(shortCode.__contains__("error")):
                        print("\nError occurred.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    elif (shortCode.__contains__("_fail")):
                        print("\nRequest failed.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    else:
                        print("\nInvalid executing state received.")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                else:
                    print("\nInvalid executing status received.\n")
                    print(executingStatus)
                    print("\n")
                    sys.exit(1)
                break
            if timeoutOccured:
                print("\nTimeout occurred.\n")
                sys.exit(1)
        - name: Sign off LitmusTest execution
          type: xlrelease.GateTask
          description: |-
            #### Hello Quality Engineer ${delivery_environment_type} Team :-

            Please review litmus test results and click "complete" to sign off.
          tags:
          - key_process_step
    - name: Post deployment certification by Quality Engineer DEV team
      type: xlrelease.GateTask
      description: |-
        #### Hello Quality Engineer ${delivery_environment_type} Team :-

        Can ${artifact_build_version_artifactoryUrl} be marked ${delivery_environment_name}-Certified=true in Artifactory ?

        Click "Complete" to confirm
      precondition: "\"${phaseEnablePostDeployGate_dev}\".lower() == \"yes\""
      tags:
      - key_process_step
      conditions:
      - name: "Tests executed, results reviewed. Build looks good ! OK to certify?"
        type: xlrelease.GateCondition
    - name: Certify build artifact version (s)
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: "Mark the artifact  ${artifactoryBuildName} certified in artifactory"
        type: xlrelease.ScriptTask
        tags:
        - key_process_step
        script: |-
          ### Set Deployment Dashboard parameters

          dashboard_delivery_environment_name = "${dashboard_delivery_environment_name}"
          dashboard_certStatus = str(dashboard_delivery_environment_name) + "-certStatus"
          ######

          full_url = "${artifact_build_version_artifactoryUrl}"
          urls_list = full_url.split(",")

          for myurl in urls_list:
              api_call_url=myurl.replace("'","")
              api_call_url=api_call_url.replace("[","")
              api_call_url=api_call_url.replace("]","")
              api_call_url=api_call_url.replace(" ","")
              api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

              artifact_url_to_update=api_call_url+"?properties="+"${delivery_environment_name}"+"-Certified=Yes"
              request = HttpRequest({'url': '${global.artifactoryurl}'})
              headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
              response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
              status = response.getStatus()

              if response.getStatus() == 204:
                  releaseVariables[dashboard_certStatus] = 'Certified'
                  print myurl, " have been certified"
                  print '\n'
              else:
                  print myurl, " could not be certified"
                  sys.exit(1)
      - name: "Mark Build Number:${artifact_build_version_buildnum_var} as a Release\
          \ Candidate"
        type: xlrelease.ScriptTask
        tags:
        - key_process_step
        script: |-
          import urllib2
          import json

          artifactoryUrl="${global.artifactoryurl}/api/search/aql"

          data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
          artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
          artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
          artifactoryRequest.add_header("Content-Type", "text/plain")
          artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
          artifactData = json.loads(artifactoryResponse)
          print type(artifactData)

          #UnTag the Previous Release Candidate
          mylist=""
          for i in xrange(len(artifactData["results"])):
              for j in xrange(len(artifactData["results"][i]["properties"])):
                  if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                      artifact_url_to_update="/api/storage"+"/"+artifactData["results"][i]["repo"]+"/"+artifactData["results"][i]["path"]+"/"+artifactData["results"][i]["name"]+"?properties="+"${release_candidate_name}"+"-Certified=No"
                      request = HttpRequest({'url': '${global.artifactoryurl}'})
                      headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                      response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                      status = response.getStatus()


          #Tag the current build as Release Candidate
          full_url = "${artifact_build_version_artifactoryUrl}"
          urls_list = full_url.split(",")
          for myurl in urls_list:
              api_call_url=myurl.replace("'","")
              api_call_url=api_call_url.replace("[","")
              api_call_url=api_call_url.replace("]","")
              api_call_url=api_call_url.replace(" ","")
              api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

              artifact_url_to_update=api_call_url+"?properties="+"${release_candidate_name}"+"-Certified=Yes"
              request = HttpRequest({'url': '${global.artifactoryurl}'})
              headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
              response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
              status = response.getStatus()
              if response.getStatus() == 204:
                  print myurl, " have been certified as a Release Candidate"
                  print '\n'
              else:
                  print myurl, " could not be certified as a Release Candidate"
                  sys.exit(1)
      - name: Phase certification summary
        type: xlrelease.ScriptTask
        script: |-
          #phase_certified_artifact_version_name="phase_certified_artifact_version_"+"${component_name}"
          releaseVariables["phase_certified_artifact_version_name"] = "${artifact_build_version_artifactoryUrl}"

          #phase_certified_artifact_property_name = "phase_certified_artifact_property_"+"${component_name}"
          releaseVariables["phase_certified_artifact_property_name"] = "${delivery_environment_name}-Certified"
    - name: Closure
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Compile Email Notification
        type: xlrelease.ScriptTask
        script: |-
          releaseVariables["email_body"] = "${spkName} ${component_name} has been successfully"
          releaseVariables["email_body_content"] =""
          phase_Title = getCurrentPhase().getTitle()
          release_Id = getCurrentRelease().getId()
          print("phase_Title==", phase_Title)
          print("Current release_Id", release_Id)
          deploy = getTasksByTitle("Deploy ${artifactoryBuildName}", phaseTitle = phase_Title, releaseId = release_Id)
          litmus = getTasksByTitle("Sign off LitmusTest execution", phaseTitle = phase_Title, releaseId = release_Id)
          cert = getTasksByTitle("Post deployment certification by Quality Engineer DEV team", phaseTitle = phase_Title, releaseId = release_Id)
          if len(deploy) != 0 and deploy[0]['status'] == "COMPLETED":
              releaseVariables["email_body"] = releaseVariables["email_body"]+" deployed "
              releaseVariables["email_body_content"] = "- #### Deployed artifacts: \n ${artifact_build_version_artifactorybrowseUrl} \n" + "- #### Refer the below url for tower job details: \n ${ansible_tower_job_url}"

          if len(litmus)!=0 and litmus[0]['status'] == "COMPLETED":
              releaseVariables["email_body"] = releaseVariables["email_body"]+", litmus test executed "

          if len(cert)!=0 and cert[0]['status'] == "COMPLETED":
              releaseVariables["email_body"] = releaseVariables["email_body"]+"& certified"
          if deploy[0]['status'] =="SKIPPED" and litmus[0]['status']=="SKIPPED" and cert[0]['status'] == "SKIPPED":
              releaseVariables["email_body"] ="Deployment, Litmus test execution and certification of ${spkName} ${component_name} has been skipped"

          releaseVariables["email_body"] = releaseVariables["email_body"]+" in ${delivery_environment_name}"
          print("Deploy status ==", deploy[0]['status'])
          print("Litmus status ==", litmus[0]['status'])
          print ("Cert status ===", cert[0]['status'])
          print(releaseVariables["email_body"])
      - name: Send release notification
        type: xlrelease.NotificationTask
        description: "#### Send email notification for ${delivery_environment_name}\
          \ release ####"
        tags:
        - key_process_step
        addresses:
        - "${release_notification_list}"
        subject: "${spkName} ${component_name} release to ${delivery_environment_name}"
        body: |-
          #### ${email_body}

          ${email_body_content}

          - #### Refer release pipeline below for more info via 2 available options (flow view , table view):
          ${delivery_pipeline_url}
    - name: Approval from Integrated Release
      type: xlrelease.GateTask
      description: "The gate will be approved by ${integrated_release_name}"
      owner: script_runner
      plannedDuration: 349200
      precondition: getCurrentRelease().title.startswith("Integrated")
      tags:
      - key_process_step
    color: '#009CDB'
  - phase: phase_template_lle
    tasks:
    - name: Set template phase details
      type: xlrelease.ScriptTask
      tags:
      - key_process_step
      script: |-
        current_phase = getCurrentPhase()

        current_phase_title_asis = current_phase.title
        current_phase_title_split = current_phase_title_asis.split('(')
        delivery_environment_name = current_phase_title_split[0]
        component_name_split = current_phase_title_split[1].split(')')
        component_name = component_name_split[0]

        releaseVariables['component_name'] = component_name
        releaseVariables['delivery_environment_name'] = delivery_environment_name
        releaseVariables['delivery_environment_type'] = ${phaseType}[delivery_environment_name]
        releaseVariables['enable_sonar_metrics_check'] = ${sonarEnableMetricsCheck}[delivery_environment_name]
        releaseVariables['ansible_tower_job_template_name'] = ${towerJobTemplate}[delivery_environment_name]
        #for DMZ integration
        releaseVariables['xlr_inventory_name'] = ${towerInventory}[delivery_environment_name]

        if delivery_environment_name in ${litmus_env_to_phase_mapping}:
            releaseVariables['litmus_phase'] = ${litmus_env_to_phase_mapping}[delivery_environment_name]
        if delivery_environment_name in ${litmusComponentName}:
            releaseVariables['litmus_test_component'] = ${litmusComponentName}[delivery_environment_name]
        if delivery_environment_name in ${litmus_env_to_app_url_mapping}:
            releaseVariables['litmus_app_url'] = ${litmus_env_to_app_url_mapping}[delivery_environment_name]
        if delivery_environment_name in ${litmusEnableFunctionalTests}:
            releaseVariables['litmus_enable_automated_tests'] = ${litmusEnableFunctionalTests}[delivery_environment_name].strip().lower()
        if delivery_environment_name in ${litmusTargetApplicationUrl}:
            releaseVariables['litmus_test_url'] = ${litmusTargetApplicationUrl}[delivery_environment_name]

        if releaseVariables['delivery_environment_type'] == 'DEV':
            releaseVariables['release_notification_list'] = "${phaseNotificationDg_dev}"
        elif releaseVariables['delivery_environment_type'] == 'LLE':
            releaseVariables['release_notification_list'] = "${phaseNotificationDg_lle}"
        elif releaseVariables['delivery_environment_type'] == 'PROD':
            releaseVariables['release_notification_list'] = "${phaseNotificationDg_prod}"
        else:
             releaseVariables['release_notification_list'] = "please_configure_some_email@domain.com"

        phase_certified_artifact_version_name="phase_certified_artifact_version"+str(component_name)
        phase_certified_artifact_property_name="phase_certified_artifact_property"+str(component_name)

        try:
            releaseVariables['phase_certified_artifact_version']=releaseVariables[phase_certified_artifact_version_name]
            releaseVariables['phase_certified_artifact_property']=releaseVariables[phase_certified_artifact_property_name]
        except:
            releaseVariables['phase_certified_artifact_version']=""
            releaseVariables['phase_certified_artifact_property']=""

        ### Set deployer ID and password

        releaseVariables['nonprod_tower_deployer_id'] = ""
        releaseVariables['nonprod_tower_deployer_password'] = ""

        if releaseVariables['towerDeployerIdNonProd']:
              releaseVariables['nonprod_tower_deployer_id'] = releaseVariables['towerDeployerIdNonProd']
              releaseVariables['nonprod_tower_deployer_password'] = releaseVariables['towerDeployerPasswordNonProd']
    - name: Update release name
      type: xlrelease.ScriptTask
      script: |-
        current_release = getCurrentRelease()

        if ("${jenkinsBuildNo}"):
            current_release.title = "{0} Build#{1} {2}".format("${original_release_title}","${jenkinsBuildNo}","${delivery_environment_name}")
        else:
            current_release.title = "{0} {1}".format("${original_release_title}","${delivery_environment_name}")

        releaseApi.updateRelease(current_release)
    - name: Acknowledge/sign off release code quality metrics
      type: xlrelease.SequentialGroup
      precondition: "releaseVariables['enable_sonar_metrics_check'] == 'Yes'"
      tags:
      - key_process_step
      tasks:
      - name: Delete Existing SonarQube token
        type: webhook.JsonWebhook
        URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
        method: POST
        username: "${global.cross_connect_userid}"
        variableMapping:
          pythonScript.password: "${global.cross_connect_password}"
      - name: Generate SonarQube token
        type: webhook.JsonWebhook
        URL: "${global.sonarurl}/api/user_tokens/generate?name=${spkComponentsToRelease}"
        method: POST
        username: "${global.cross_connect_userid}"
        jsonPathExpression: $.token
        variableMapping:
          pythonScript.result: "${SonarQube_token}"
          pythonScript.password: "${global.cross_connect_password}"
      - name: "Reading SonarQube Metrics for  ${sonarComponentKey}"
        type: xlrelease.ScriptTask
        script: |-
          import urllib2
          import json
          import base64

          # defining the api-endpoint

          url="${global.sonarurl}/api/measures/component?componentKey=${sonarComponentKey}&metricKeys=alert_status,bugs,blocker_violations,critical_violations,vulnerabilities,code_smells,duplicated_blocks,duplicated_lines_density,ncloc"

          print("URL....", url)

          token = releaseVariables['SonarQube_token'] + ":"
          encodedToken =  base64.encodestring(token).rstrip('\n')
          print ("Encodedtoken= ", encodedToken)

          req=urllib2.Request(url=url)
          req.add_header('Authorization', "Basic %s" % encodedToken)
          req.add_header("Content-Type", "application/json")

          jobResponse=urllib2.urlopen(req).read()

          print("JOB Response", jobResponse)

          json_data = json.loads(jobResponse)

          print ("\n JSON DATA....",json_data)

          metrics_data = {}
          for item in json_data['component']['measures']:
              metrics_data[item['metric']] = item['value']

          releaseVariables['sonarqube_bugs']  = int(metrics_data.get('bugs'))

          releaseVariables['sonarqube_blocker_violations']  = int(metrics_data.get('blocker_violations'))

          releaseVariables['sonarqube_critical_violations']  = int(metrics_data.get('critical_violations'))
          releaseVariables['sonarqube_vulnerabilities'] = int(metrics_data.get('vulnerabilities'))
          releaseVariables['sonarqube_code_smells'] = int(metrics_data.get('code_smells'))
          releaseVariables['sonarqube_duplicated_blocks'] = int(metrics_data.get('duplicated_blocks'))
          releaseVariables['sonarqube_duplicated_lines_density'] = metrics_data.get('duplicated_lines_density')
          releaseVariables['sonarqube_ncloc'] = int(metrics_data.get('ncloc'))

          gg = metrics_data.get('alert_status')

          if gg == "OK":
              releaseVariables['sonarqube_quality_gate'] = "PASSED"

          if gg == "ERROR":
             releaseVariables['sonarqube_quality_gate'] = "FAILED"
      - name: Delete SonarQube token
        type: webhook.JsonWebhook
        URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
        method: POST
        username: "${global.cross_connect_userid}"
        variableMapping:
          pythonScript.password: "${global.cross_connect_password}"
      - name: Sign off on SonarQube metrics for the release
        type: xlrelease.GateTask
        description: |-
          - Quality Gate :  ${sonarqube_quality_gate}
          - Bugs: ${sonarqube_bugs}
          - Blocker Violations: ${sonarqube_blocker_violations}
          - Critical Violations: ${sonarqube_critical_violations}
          - Vulnerabilities: ${sonarqube_vulnerabilities}
          - Code Smells: ${sonarqube_code_smells}
          - Duplicated Blocks: ${sonarqube_duplicated_blocks}
          - Duplicated Line Density: ${sonarqube_duplicated_lines_density}
          - Lines of Code: ${sonarqube_ncloc}
        tags:
        - key_process_step
    - name: Pre-tasks for DMZ deployment
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Validate Inventory configured in tower Job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: $..inventory
        variableMapping:
          pythonScript.result: "${ansible_template_inventory_name}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Get Inventory name from Tower Job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].summary_fields.inventory.name"
        precondition: "releaseVariables['ansible_template_inventory_name']!=\"[null]\""
        variableMapping:
          pythonScript.result: "${tower_job_inventory_name}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Validate inventory
        type: xlrelease.ScriptTask
        script: |-
          if releaseVariables['ansible_template_inventory_name']!='[null]' and releaseVariables['xlr_inventory_name']!="":
              if releaseVariables['tower_job_inventory_name'] == releaseVariables['xlr_inventory_name']:
                  print "Inventory name in XLR and Tower are same, Good to go!"
              elif releaseVariables['tower_job_inventory_name'] != releaseVariables['xlr_inventory_name']:
                 print """Ansible tower job_template '${ansible_tower_job_template_name}' is not correctly configured to accept an inventory as input \n Please remove inventory name and update the tower job_template with ('prompt on launch')"""
                 sys.exit(1)
          elif releaseVariables['ansible_template_inventory_name']=='[null]' and releaseVariables['xlr_inventory_name']=="":
              print "Ansible tower job_template '${ansible_tower_job_template_name}'is not configured with an inventory name, please configure valid inventory name"
              sys.exit(1)
          print "Validation looks Good !"
      - name: Construct Instance group url  from ansible Job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].related.instance_groups"
        variableMapping:
          pythonScript.password: "${nonprod_tower_deployer_password}"
          pythonScript.result: "${ansible_tower_job_template_instance_group_url}"
      - name: Get Instance group details from instance group url
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}${ansible_tower_job_template_instance_group_url}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: results
        variableMapping:
          pythonScript.result: "${ansible_tower_instance_group_from_template}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Get Ansible inventory id from XLR template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/inventories?name=${xlr_inventory_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].id"
        precondition: "releaseVariables['xlr_inventory_name'] !=\"\""
        variableMapping:
          pythonScript.result: "${ansible_tower_job_inventory}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Get Inventory id from ansible job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].summary_fields.inventory.id"
        precondition: "releaseVariables['xlr_inventory_name'] ==\"\""
        variableMapping:
          pythonScript.result: "${ansible_tower_job_inventory}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: Get Ansible Instance group from inventory id
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/inventories/${ansible_tower_job_inventory}/instance_groups"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: results
        variableMapping:
          pythonScript.password: "${nonprod_tower_deployer_password}"
          pythonScript.result: "${ansible_tower_instance_group}"
      - name: "Determine Artifactory : DMZ or Baronet"
        type: xlrelease.ScriptTask
        script: |-
          releaseVariables['deployDMZ_lle']="No"
          releaseVariables['ansible_tower_job_inventory_id']=0
          jobtemplate_deploydmz ="No"
          inventory_deploydmz = "No"
          instance_group_match ="No"
          if releaseVariables['xlr_inventory_name'] =="":
              releaseVariables['ansible_tower_job_inventory_id']=0
          elif releaseVariables['xlr_inventory_name'] !="":
              releaseVariables['ansible_tower_job_inventory_id'] = int (releaseVariables['ansible_tower_job_inventory'])
          print ("Inventory_id passing from XLR to Tower job template =>",releaseVariables['ansible_tower_job_inventory_id'])

          if "ztwr" in releaseVariables['ansible_tower_instance_group']:
              inventory_deploydmz="Yes"
          elif "ztwr" not in releaseVariables['ansible_tower_instance_group']:
              inventory_deploydmz="No"
          if inventory_deploydmz =="No":
              if "ztwr" not in releaseVariables['ansible_tower_instance_group'] and releaseVariables['ansible_tower_instance_group'] !="[]":
                  inventory_instance_grp = "Yes"
              elif releaseVariables['ansible_tower_instance_group'] =="[]":
                  inventory_instance_grp = "No"
              print ("inventory_instance_grp==>", inventory_instance_grp)

          if "ztwr" in releaseVariables['ansible_tower_instance_group_from_template']:
              jobtemplate_deploydmz="Yes"
          elif "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template']:
              jobtemplate_deploydmz = "No"

          if jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="Yes":
              print """Instance group in inventory configured with non-DMZ but instance group in tower job template configured with DMZ \n Always job template instance group take precedence, so please configure your Tower job template properly"""
              sys.exit(1)
          elif jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="No":
              releaseVariables['deployDMZ_lle'] = "Yes"
          elif jobtemplate_deploydmz == "Yes" and inventory_deploydmz=="Yes":
              if "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              elif "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              elif "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              elif "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              if instance_group_match == "Yes":
                  releaseVariables['deployDMZ_lle'] = "Yes"
              else:
                  print """DMZ instance group configured in inventory does not match with DMZ instance group configured in job template...\n Please configure them correctly!!"""
                  sys.exit(1)

          if jobtemplate_deploydmz=="No":
              if "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template'] and releaseVariables['ansible_tower_instance_group_from_template'] !="[]":
                  template_instance_grp = "Yes"
              elif releaseVariables['ansible_tower_instance_group_from_template'] =="[]":
                  template_instance_grp = "No"
              print ("template_instance_grp==>", template_instance_grp)
              if template_instance_grp == "Yes" and inventory_deploydmz=="Yes":
                  print """Your inventory's instance group configured with DMZ But Your job template's instance group not configured with DMZ. \n Always job template instance group take precedence, so please configure your Tower job template properly"""
                  releaseVariables['deployDMZ_lle'] = "No"
                  sys.exit(1)
              elif template_instance_grp == "No" and inventory_deploydmz=="Yes":
                  releaseVariables['deployDMZ_lle'] = "Yes"
              elif template_instance_grp == "No" and inventory_deploydmz=="No":
                  releaseVariables['deployDMZ_lle'] = "No"
          print ("inventory_dmz==>", inventory_deploydmz)
          print ("jobtemplate_dmz==>", jobtemplate_deploydmz)
          print("<-------------------deployDMZ---------->", releaseVariables['deployDMZ_lle'])
    - name: Get build artifact version (s) to deploy
      type: xlrelease.SequentialGroup
      tasks:
      - name: Artifactory API key generation
        type: xlrelease.SequentialGroup
        description: '### This task will generate encrypted API key that can be used
          in the fetch artifact version script tasks of this release template'
        tasks:
        - name: GET
          type: webhook.JsonWebhook
          URL: "${global.artifactoryurl}/api/security/apiKey"
          username: "${global.cross_connect_userid}"
          jsonPathExpression: $.apiKey
          variableMapping:
            pythonScript.result: "${ArtifactoryAPIkey}"
            pythonScript.password: "${global.cross_connect_password}"
      - name: Get build artifact's Release Candidate Version
        type: xlrelease.ScriptTask
        description: "#### This task will get latest version of the build artifact\
          \  ####"
        script: |-
          import urllib2
          import json

          artifactoryUrl="${global.artifactoryurl}/api/search/aql"
          certification_history = ""

          data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
          artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
          artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
          artifactoryRequest.add_header("Content-Type", "text/plain")
          artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
          artifactData = json.loads(artifactoryResponse)

          myprop={}
          for i in xrange(len(artifactData["results"])):
              for j in xrange(len(artifactData["results"][i]["properties"])):
                  if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                      releaseVariables["artifact_build_version_ciurl_var"]=artifactData["results"][i]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]
                      myprop=artifactData["results"][i]["properties"]

          for i in xrange(len(myprop)):
              if (myprop[i]["key"] == "build.number"):
                  releaseVariables["artifact_build_version_buildnum_var"]=myprop[i]["value"]
              if (myprop[i]["key"] == "ait.number"):
                  releaseVariables["artifact_build_version_ait_var"]=myprop[i]["value"]
              if (myprop[i]["key"] == "scm.location"):
                  releaseVariables["artifact_build_version_scmloc_var"]=myprop[i]["value"]
              if (myprop[i]["key"] == "scm.branch"):
                  releaseVariables["artifact_build_version_scmbranch_var"]=myprop[i]["value"]
              if ("Certified" in myprop[i]["key"]):
                  certification_history="\n\n" + myprop[i]["key"] + "=" + myprop[i]["value"]+"\n\n"+certification_history

          releaseVariables["artifactory_certification_history"]=certification_history

          data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",releaseVariables["artifact_build_version_buildnum_var"])
          artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
          artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
          artifactoryRequest2.add_header("Content-Type", "text/plain")
          jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
          artifactData2 = json.loads(jobResponse2)

          mylist=""
          for index in range(len(artifactData2["results"])):
              data_url="https://artifacts.customer.domain.com/artifactory"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
              if(mylist==""):
                  mylist=data_url
              else:
                  mylist=mylist+","+data_url

          if ',' in mylist:
              mylist=mylist.replace(",","', '")
              mylist= "['"+mylist+"']"

          releaseVariables["artifact_build_version_artifactoryUrl"] = mylist


          releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"
          releaseVariables["old_artifact_build_version_artifactoryUrl"]=releaseVariables["artifact_build_version_artifactoryUrl"]
          releaseVariables["old_artifact_build_version_buildnum_var"]=releaseVariables["artifact_build_version_buildnum_var"]
    - name: Deployment approval by Deployer LLE team
      type: xlrelease.UserInputTask
      description: |-
        #### Hello Deployer ${delivery_environment_type} Team :-
        ${phase_certified_artifact_property} ${phase_certified_artifact_version}

        Tower job template ${ansible_tower_job_template_name} will deploy the following build to ${delivery_environment_name}

        ${artifact_build_version_artifactorybrowseUrl}

        Certification History:
        ${artifactory_certification_history}

        Click "Complete" to to kick off deployment job in tower
      precondition: "\"${phaseEnablePreDeployGate_lle}\".lower() == \"yes\""
      tags:
      - key_process_step
      variables:
      - artifact_build_version_artifactoryUrl
      - artifact_build_version_buildnum_var
      - nonprod_tower_deployer_id
      - nonprod_tower_deployer_password
    - name: Deploy application changes/build
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Construct artifactory url for deployment
        type: xlrelease.ScriptTask
        description: "#### This task will get latest version of the build artifact\
          \  ####"
        script: |-
          import urllib2
          import json

          artifactoryUrl="${global.artifactoryurl}/api/search/aql"
          myNewUrl="${artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
          myNewUrl=myNewUrl.replace("webapp/#/artifacts/browse/tree/General/","")
          myNewUrl=myNewUrl.replace("${artifactoryBuildRepo}/","")
          myNewUrl=myNewUrl.replace("[","")
          myNewUrl=myNewUrl.replace("]","")
          myNewUrl=myNewUrl.replace("'","")
          myNewUrlList=myNewUrl.split(",")


          myOldUrl="${old_artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
          myOldUrl=myOldUrl.replace("webapp/#/artifacts/browse/tree/General/","")
          myOldUrl=myOldUrl.replace("${artifactoryBuildRepo}/","")
          myOldUrl=myOldUrl.replace("[","")
          myOldUrl=myOldUrl.replace("]","")
          myOldUrl=myOldUrl.replace("'","")
          myOldUrlList=myOldUrl.split(",")

          releaseVariables["isReleaseCandidate"]="No"

          def GetFinalArtifactUrlList(buildNumber):
              data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %("${artifactoryBuildRepo}","${artifactoryBuildName}",buildNumber)
              artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
              artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest2.add_header("Content-Type", "text/plain")
              jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
              artifactData2 = json.loads(jobResponse2)

              mylist=""
              for index in range(len(artifactData2["results"])):
                  data_url="${global.artifactoryurl}"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                  if(mylist==""):
                      mylist=data_url
                  else:
                      mylist=mylist+","+data_url

              if ',' in mylist:
                  mylist=mylist.replace(",","', '")
                  mylist= "['"+mylist+"']"

              releaseVariables["artifact_build_version_artifactoryUrl"] = mylist
              releaseVariables["artifact_build_version_path_var"]=artifactData2["results"][index]["path"]
              releaseVariables["artifact_build_version_name_var"]=artifactData2["results"][index]["name"]

          def GetFinalArtifactData(myPathName,myArtifactName):
              data1="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"path\":{\"$match\":\"%s\"}},{\"name\":{\"$match\":\"%s\"}}).include(\"name\",\"repo\",\"path\",\"created\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",myPathName,myArtifactName)
              artifactoryRequest1=urllib2.Request(url=artifactoryUrl,data=data1)
              artifactoryRequest1.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest1.add_header("Content-Type", "text/plain")
              jobResponse1=urllib2.urlopen(artifactoryRequest1).read()
              artifactData1 = json.loads(jobResponse1)

              releaseVariables["artifact_build_version_ciurl_var"]=artifactData1["results"][0]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]

              for i in xrange(len(artifactData1["results"][0]["properties"])):
                  if (artifactData1["results"][0]["properties"][i]["key"] == "ait.number"):
                      releaseVariables["artifact_build_version_ait_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "scm.location"):
                      releaseVariables["artifact_build_version_scmloc_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "build.number"):
                      releaseVariables["artifact_build_version_buildnum_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "scm.branch"):
                      releaseVariables["artifact_build_version_scmbranch_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "${release_candidate_name}-Certified" and artifactData1["results"][0]["properties"][i]["value"] == "Yes"):
                      releaseVariables["isReleaseCandidate"]="Yes"


          if "${old_artifact_build_version_buildnum_var}" != "${artifact_build_version_buildnum_var}":
              GetFinalArtifactUrlList("${artifact_build_version_buildnum_var}")
              GetFinalArtifactData(releaseVariables["artifact_build_version_path_var"],releaseVariables["artifact_build_version_name_var"])
              if (releaseVariables["isReleaseCandidate"] == "No"):
                  print 'The details entered does not correspond to a release candidate build.'
                  sys.exit(1)
          elif myNewUrlList[0] not in myOldUrlList:
              myNewUrl=myNewUrlList[0].rsplit('/', 1)
              GetFinalArtifactData(myNewUrl[0],myNewUrl[1])
              if (releaseVariables["isReleaseCandidate"] == "No"):
                  print 'The details entered does not correspond to a release candidate build.'
                  sys.exit(1)


          releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"

          ### Set Deployment Dashboard parameters

          spkName = "${spkName}".upper().strip()
          delivery_environment_name = "${delivery_environment_name}".upper().strip()
          dashboard_delivery_environment_name = spkName + "-" + delivery_environment_name
          releaseVariables['dashboard_delivery_environment_name'] = dashboard_delivery_environment_name

          # ID
          dashboard_deployerId = str(dashboard_delivery_environment_name) + "-deployerId"
          releaseVariables[dashboard_deployerId] = "${nonprod_tower_deployer_id}"

          ###XLR DMZ Integration
          if releaseVariables['deployDMZ_lle']=="Yes":
                  releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl'].replace("${global.artifactoryurl}","${global.dmzArtifactoryUrl_NonProd}")
          else:
              releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl']
          print("deployDMZ_lle==", releaseVariables['deployDMZ_lle'])
          print("Artifactory URL==", releaseVariables['published_artifact_url'])
      - name: Get job template id
        type: webhook.JsonWebhook
        URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${nonprod_tower_deployer_id}"
        jsonPathExpression: "results[0].id"
        variableMapping:
          pythonScript.result: "${ansible_tower_job_template_id}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
      - name: "Deploy ${artifactoryBuildName}"
        type: ansible.LaunchJobTemplate
        username: "${nonprod_tower_deployer_id}"
        jobTemplate: "${ansible_tower_job_template_id}"
        credential: "0"
        description: "## Deploy ${artifactoryBuildName}"
        facets:
        - type: udm.DeploymentTaskFacet
          variableMapping:
            environmentId: "${dashboard_delivery_environment_name}"
            applicationId: "${component_name}"
            version: "${artifact_build_version_buildnum_var}"
        variableMapping:
          pythonScript.jobId: "${ansible_job_id}"
          pythonScript.password: "${nonprod_tower_deployer_password}"
          pythonScript.inventory: "${ansible_tower_job_inventory_id}"
        tags:
        - key_process_step
      - name: Fetch ansible job log
        type: xlrelease.ScriptTask
        description: "#### This task will get latest version of the build artifact\
          \  ####"
        script: "releaseVariables[\"ansible_tower_job_url\"]=\"${global.ansible-non-prod-towerurl}/#/jobs/${ansible_job_id}\""
    - name: Kick off litmus tests
      type: xlrelease.SequentialGroup
      precondition: "\"${litmus_enable_automated_tests}\".lower() == \"yes\""
      tags:
      - key_process_step
      tasks:
      - name: Validate LitmusTest input
        type: xlrelease.ScriptTask
        script: |-
          val = "${artifact_build_version_ait_var}"
          if not val: raise ValueError("ait_number is mandatory parameter for LitmusTest execution.")

          val = "${litmus_test_component}"
          if not val: raise ValueError("litmusComponentName is mandatory parameter for LitmusTest execution. Please fill it with valid value for your environment.")

          val = "${litmus_test_url}"
          if not val: raise ValueError("litmusTargetApplicationUrl is mandatory parameter for LitmusTest execution.Please fill it with valid value for your environment.")

          val = "${litmus_spk}"
          if not val: raise ValueError("litmus_spk is mandatory parameter for LitmusTest execution.")

          releaseVariables['litmus_input_validated'] = True
      - name: Submit Litmus Request
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['litmus_input_validated'] == True"
        script: |-
          import urllib2
          import json
          import datetime
          import sys

          payload = {
            "BuildRunID": "" ,
            "AIT": "${artifact_build_version_ait_var}",
            "SPK": "${litmus_spk}",
            "JobStatus": "New",
            "DeployedDate": str(datetime.datetime.now()),
            "TestPhase": "${litmus_phase}",
            "ApplicationURL": "${litmus_app_url}",
            "EnvironmentName": "${delivery_environment_name}",
            "Component": "${litmus_test_component}",
            "Requestor":"XLR"
          }
          print("Req to be submitted to LitmusTest is - \n")
          print(payload)

          # Send req to Litmus
          data=json.dumps(payload)

          baseURL = "${litmus_test_url}"
          if not baseURL.endswith("/"):
              baseURL = baseURL +"/"
          url = baseURL+"LitmusTest/InsertEvent"

          req=urllib2.Request(url=url ,data=data)
          req.add_header("Content-Type", "application/json")
          response=urllib2.urlopen(req).read()
          message = json.loads(response)
          print("\nResponse received-\n")
          print(message)
          requestStatus = message["requestStatus"]
          releaseVariables['litmus_request_id'] = message["requestId"]
          if requestStatus == "Request has been successfully queued.":
            releaseVariables['req_submitted'] = True
            print("\nRequest has been submitted to LitmusTest with requestId - "+ str(message["requestId"]))
          else:
              print("\nRequest could not be submitted to LitmusTest.\n")
              print (requestStatus)
              print("\n")
              sys.exit(1)
      - name: Process Response
        type: xlrelease.SequentialGroup
        precondition: "releaseVariables['req_submitted'] == True"
        tasks:
        - name: Process Smoke Test Response
          type: xlrelease.ScriptTask
          script: |-
            import json
            import urllib2
            import time
            import sys

            payload = {
                "requestId":${litmus_request_id}
            }

            # Send req to Litmus for status check
            data = json.dumps(payload)
            baseURL = "${litmus_test_url}"
            if not baseURL.endswith("/"):
                baseURL = baseURL + "/"
            url = baseURL + "LitmusTest/GetRequestStatus"

            timePassed = 0
            timeoutOccured = True
            while (timePassed < int(${litmus_smoke_timeout})):
                time.sleep(${litmus_polling_interval})
                timePassed = timePassed + ${litmus_polling_interval}

                req = urllib2.Request(url=url, data=data)
                req.add_header("Content-Type", "application/json")
                response = urllib2.urlopen(req).read()
                message = json.loads(response)

                executingStatus = message["executingStatus"]
                returnCode = message["executingState"]
                index = returnCode.find("(")
                shortCode = returnCode
                if index != -1:
                    shortCode = returnCode[:returnCode.find("(")]
                shortCode = shortCode.lower()

                if (executingStatus == 'Waiting' or executingStatus == 'Smoke Executing'):
                    continue
                print(message)
                print("\n")
                print("\n")
                timeoutOccured = False
                executionDetails = message["executionDetails"]
                if (executingStatus.__contains__("Executing")):
                    if (shortCode == "smoke_pass1"):
                        print("\nSmoke Test passed, Basic Test is scheduled.")
                        releaseVariables['litmus_process_basic'] = True
                    elif (shortCode == "smoke_pass2"):
                        print("\nSmoke Passed, Regression Test is scheduled")
                        releaseVariables['litmus_process_regression'] = True
                    elif (shortCode == "basic_pass"):
                        print("\nBasic Passed, Regression Test is scheduled")
                        releaseVariables['litmus_process_regression'] = True
                    else:
                        print("\nInvalid executing state received.\n")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                    print("\nTest execution summary- ")
                    for eDetail in executionDetails:
                        print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                            eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + eDetail["threshold"])
                elif (executingStatus == 'Complete'):
                    if (shortCode == "request complete"):
                        print("\nRequest has been successfully completed.\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        releaseVariables['litmus_test_passed'] = True
                    elif (shortCode.__contains__("error")):
                        print("\nError occurred.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    elif (shortCode.__contains__("_fail")):
                        print("\nRequest failed.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    else:
                        print("\nInvalid executing state received.\n")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                else:
                    print("\nInvalid executing status received.\n")
                    print(executingStatus)
                    print("\n")
                    sys.exit(1)
                break
            if timeoutOccured:
                print("\nTimeout occurred.\n")
                sys.exit(1)
        - name: Process Basic Test Response
          type: xlrelease.ScriptTask
          precondition: "releaseVariables['litmus_process_basic'] == True"
          script: |-
            import json
            import urllib2
            import time
            import sys

            payload = {
                "requestId":${litmus_request_id}
            }

            # Send req to Litmus for status check
            data = json.dumps(payload)
            baseURL = "${litmus_test_url}"
            if not baseURL.endswith("/"):
                baseURL = baseURL + "/"
            url = baseURL + "LitmusTest/GetRequestStatus"

            timePassed = 0
            timeoutOccured = True
            while (timePassed < int(${litmus_basic_timeout})):
                time.sleep(${litmus_polling_interval})
                timePassed = timePassed + ${litmus_polling_interval}

                req = urllib2.Request(url=url, data=data)
                req.add_header("Content-Type", "application/json")
                response = urllib2.urlopen(req).read()
                message = json.loads(response)
                executingStatus = message["executingStatus"]
                returnCode = message["executingState"]
                index = returnCode.find("(")
                shortCode = returnCode
                if index != -1:
                    shortCode = returnCode[:returnCode.find("(")]
                shortCode = shortCode.lower()

                if (executingStatus == 'Basic Executing'):
                    continue
                print(message)
                print("\n")
                print("\n")
                timeoutOccured = False
                executionDetails = message["executionDetails"]
                if (executingStatus == "Regression Executing"):
                    if (shortCode == "basic_pass"):
                        print("\nBasic Passed, Regression Test is scheduled\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        releaseVariables['litmus_process_regression'] = True
                    else:
                        print("\nInvalid executing state received.\n")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                elif (executingStatus == 'Complete'):
                    if (shortCode == "request complete"):
                        print("\nRequest has been successfully completed.\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        releaseVariables['litmus_test_passed'] = True
                    elif (shortCode.__contains__("error")):
                        print("\nError occurred.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    elif (shortCode.__contains__("_fail")):
                        print("\nRequest failed.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    else:
                        print("\nInvalid executing state received.")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                else:
                    print("\nInvalid executing status received.\n")
                    print(executingStatus)
                    print("\n")
                    sys.exit(1)
                break
            if timeoutOccured:
                print("\nTimeout occurred.\n")
                sys.exit(1)
        - name: Process Regression Test Response
          type: xlrelease.ScriptTask
          precondition: "releaseVariables['litmus_process_regression'] == True"
          script: |-
            import json
            import urllib2
            import time
            import sys

            payload = {
              "requestId":${litmus_request_id}
            }

            # Send req to Litmus for status check
            data = json.dumps(payload)
            baseURL = "${litmus_test_url}"
            if not baseURL.endswith("/"):
                baseURL = baseURL +"/"
            url = baseURL+"LitmusTest/GetRequestStatus"

            timePassed = 0
            timeoutOccured = True
            while (timePassed < int(${litmus_regression_timeout})):
                time.sleep(${litmus_polling_interval})
                timePassed = timePassed+ ${litmus_polling_interval}

                req = urllib2.Request(url=url, data=data)
                req.add_header("Content-Type", "application/json")
                response = urllib2.urlopen(req).read()
                message = json.loads(response)

                executingStatus = message["executingStatus"]
                returnCode = message["executingState"]
                index = returnCode.find("(")
                shortCode = returnCode
                if index != -1:
                    shortCode = returnCode[:returnCode.find("(")]
                shortCode = shortCode.lower()
                if (executingStatus == 'Regression Executing' ):
                    continue
                print(message)
                print("\n")
                print("\n")
                timeoutOccured = False
                executionDetails = message["executionDetails"]
                if(executingStatus == 'Complete'):
                    if(shortCode == "request complete"):
                        print("\nRequest has been successfully completed.\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                        releaseVariables['litmus_test_passed'] = True
                    elif(shortCode.__contains__("error")):
                        print("\nError occurred.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    elif (shortCode.__contains__("_fail")):
                        print("\nRequest failed.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    else:
                        print("\nInvalid executing state received.")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                else:
                    print("\nInvalid executing status received.\n")
                    print(executingStatus)
                    print("\n")
                    sys.exit(1)
                break
            if timeoutOccured:
                print("\nTimeout occurred.\n")
                sys.exit(1)
        - name: Sign off LitmusTest execution
          type: xlrelease.GateTask
          description: |-
            #### Hello Quality Engineer ${delivery_environment_type} Team :-

            Please review litmus test results and click "complete" to sign off.
          tags:
          - key_process_step
    - name: Post deployment certification by Quality Engineer LLE team
      type: xlrelease.GateTask
      description: |-
        #### Hello Quality Engineer ${delivery_environment_type} Team :-

        Can ${artifact_build_version_artifactoryUrl} be marked ${delivery_environment_name}-Certified=true in Artifactory ?

        Click "Complete" to confirm
      precondition: "\"${phaseEnablePostDeployGate_lle}\".lower() == \"yes\""
      tags:
      - key_process_step
      conditions:
      - name: "Tests executed, results reviewed. Build looks good ! OK to certify?"
        type: xlrelease.GateCondition
    - name: Certify build artifact version (s)
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: "Mark the artifact  ${artifactoryBuildName} certified in artifactory"
        type: xlrelease.ScriptTask
        tags:
        - key_process_step
        script: |-
          ### Set Deployment Dashboard parameters

          dashboard_delivery_environment_name = "${dashboard_delivery_environment_name}"
          dashboard_certStatus = str(dashboard_delivery_environment_name) + "-certStatus"
          ######

          full_url = "${artifact_build_version_artifactoryUrl}"
          urls_list = full_url.split(",")

          for myurl in urls_list:
              api_call_url=myurl.replace("'","")
              api_call_url=api_call_url.replace("[","")
              api_call_url=api_call_url.replace("]","")
              api_call_url=api_call_url.replace(" ","")
              api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

              artifact_url_to_update=api_call_url+"?properties="+"${delivery_environment_name}"+"-Certified=Yes"
              request = HttpRequest({'url': '${global.artifactoryurl}'})
              headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
              response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
              status = response.getStatus()

              if response.getStatus() == 204:
                  releaseVariables[dashboard_certStatus] = 'Certified'
                  print myurl, " have been certified"
                  print '\n'
              else:
                  print myurl, " could not be certified"
                  sys.exit(1)
      - name: "Mark Build Number:${artifact_build_version_buildnum_var} as a Release\
          \ Candidate"
        type: xlrelease.ScriptTask
        tags:
        - key_process_step
        script: |-
          import urllib2
          import json

          artifactoryUrl="${global.artifactoryurl}/api/search/aql"

          data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
          artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
          artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
          artifactoryRequest.add_header("Content-Type", "text/plain")
          artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
          artifactData = json.loads(artifactoryResponse)
          print type(artifactData)

          #UnTag the Previous Release Candidate
          mylist=""
          for i in xrange(len(artifactData["results"])):
              for j in xrange(len(artifactData["results"][i]["properties"])):
                  if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                      artifact_url_to_update="/api/storage"+"/"+artifactData["results"][i]["repo"]+"/"+artifactData["results"][i]["path"]+"/"+artifactData["results"][i]["name"]+"?properties="+"${release_candidate_name}"+"-Certified=No"
                      request = HttpRequest({'url': '${global.artifactoryurl}'})
                      headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                      response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                      status = response.getStatus()


          #Tag the current build as Release Candidate
          full_url = "${artifact_build_version_artifactoryUrl}"
          urls_list = full_url.split(",")
          for myurl in urls_list:
              api_call_url=myurl.replace("'","")
              api_call_url=api_call_url.replace("[","")
              api_call_url=api_call_url.replace("]","")
              api_call_url=api_call_url.replace(" ","")
              api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

              artifact_url_to_update=api_call_url+"?properties="+"${release_candidate_name}"+"-Certified=Yes"
              request = HttpRequest({'url': '${global.artifactoryurl}'})
              headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
              response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
              status = response.getStatus()
              if response.getStatus() == 204:
                  print myurl, " have been certified as a Release Candidate"
                  print '\n'
              else:
                  print myurl, " could not be certified as a Release Candidate"
                  sys.exit(1)
      - name: Phase certification summary
        type: xlrelease.ScriptTask
        script: |-
          #phase_certified_artifact_version_name="phase_certified_artifact_version_"+"${component_name}"
          releaseVariables["phase_certified_artifact_version_name"] = "${artifact_build_version_artifactoryUrl}"

          #phase_certified_artifact_property_name = "phase_certified_artifact_property_"+"${component_name}"
          releaseVariables["phase_certified_artifact_property_name"] = "${delivery_environment_name}-Certified"
    - name: Closure
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Compile Email Notification
        type: xlrelease.ScriptTask
        script: |-
          releaseVariables["email_body"] = "${spkName} ${component_name} has been successfully"
          releaseVariables["email_body_content"] =""
          phase_Title = getCurrentPhase().getTitle()
          release_Id = getCurrentRelease().getId()
          print("phase_Title==", phase_Title)
          print("Current release_Id", release_Id)

          deploy = getTasksByTitle("Deploy ${artifactoryBuildName}", phaseTitle = phase_Title, releaseId = release_Id)
          litmus = getTasksByTitle("Sign off LitmusTest execution", phaseTitle = phase_Title, releaseId = release_Id)
          cert = getTasksByTitle("Post deployment certification by Quality Engineer LLE team", phaseTitle = phase_Title, releaseId = release_Id)

          if len(deploy) != 0 and deploy[0]['status'] == "COMPLETED":
              releaseVariables["email_body"] = releaseVariables["email_body"]+" deployed "
              releaseVariables["email_body_content"] = "- #### Deployed artifacts: \n ${artifact_build_version_artifactorybrowseUrl} \n" + "- #### Refer the below url for tower job details: \n ${ansible_tower_job_url}"

          if len(litmus)!=0 and litmus[0]['status'] == "COMPLETED":
              releaseVariables["email_body"] = releaseVariables["email_body"]+", litmus test executed "

          if len(cert)!=0 and cert[0]['status'] == "COMPLETED":
              releaseVariables["email_body"] = releaseVariables["email_body"]+"& certified"

          if deploy[0]['status'] =="SKIPPED" and litmus[0]['status']=="SKIPPED" and cert[0]['status'] == "SKIPPED":
              releaseVariables["email_body"] ="Deployment, Litmus test execution and certification of ${spkName} ${component_name} has been skipped"

          releaseVariables["email_body"] = releaseVariables["email_body"]+" in ${delivery_environment_name}"
          print("Deploy status ==", deploy[0]['status'])
          print("Litmus status ==", litmus[0]['status'])
          print ("Cert status ===", cert[0]['status'])
          print(releaseVariables["email_body"])
      - name: Send release notification
        type: xlrelease.NotificationTask
        description: "#### Send email notification for ${delivery_environment_name}\
          \ release ####"
        tags:
        - key_process_step
        addresses:
        - "${release_notification_list}"
        subject: "${spkName} ${component_name} release to ${delivery_environment_name}"
        body: |-
          #### ${email_body}

          ${email_body_content}

          - #### Refer release pipeline below for more info via 2 available options (flow view , table view):
          ${delivery_pipeline_url}
    - name: Approval from Integrated Release
      type: xlrelease.GateTask
      description: "The gate will be approved by ${integrated_release_name}"
      owner: script_runner
      plannedDuration: 349200
      precondition: getCurrentRelease().title.startswith("Integrated")
      tags:
      - key_process_step
    color: '#009CDB'
  - phase: phase_template_prod
    tasks:
    - name: Set template phase details
      type: xlrelease.ScriptTask
      tags:
      - key_process_step
      script: |-
        current_phase = getCurrentPhase()

        current_phase_title_asis = current_phase.title
        current_phase_title_split = current_phase_title_asis.split('(')
        delivery_environment_name = current_phase_title_split[0]
        component_name_split = current_phase_title_split[1].split(')')
        component_name = component_name_split[0]

        releaseVariables['component_name'] = component_name
        releaseVariables['delivery_environment_name'] = delivery_environment_name
        releaseVariables['delivery_environment_type'] = ${phaseType}[delivery_environment_name]
        releaseVariables['enable_sonar_metrics_check'] = ${sonarEnableMetricsCheck}[delivery_environment_name]
        releaseVariables['ansible_tower_job_template_name'] = ${towerJobTemplate}[delivery_environment_name]
        #for DMZ integration
        releaseVariables['xlr_inventory_name'] = ${towerInventory}[delivery_environment_name]

        if delivery_environment_name in ${litmus_env_to_phase_mapping}:
            releaseVariables['litmus_phase'] = ${litmus_env_to_phase_mapping}[delivery_environment_name]
        if delivery_environment_name in ${litmusComponentName}:
            releaseVariables['litmus_test_component'] = ${litmusComponentName}[delivery_environment_name]
        if delivery_environment_name in ${litmus_env_to_app_url_mapping}:
            releaseVariables['litmus_app_url'] = ${litmus_env_to_app_url_mapping}[delivery_environment_name]
        if delivery_environment_name in ${litmusEnableFunctionalTests}:
            releaseVariables['litmus_enable_automated_tests'] = ${litmusEnableFunctionalTests}[delivery_environment_name].strip().lower()
        if delivery_environment_name in ${litmusTargetApplicationUrl}:
            releaseVariables['litmus_test_url'] = ${litmusTargetApplicationUrl}[delivery_environment_name]

        if releaseVariables['delivery_environment_type'] == 'DEV':
            releaseVariables['release_notification_list'] = "${phaseNotificationDg_dev}"
        elif releaseVariables['delivery_environment_type'] == 'LLE':
            releaseVariables['release_notification_list'] = "${phaseNotificationDg_lle}"
        elif releaseVariables['delivery_environment_type'] == 'PROD':
            releaseVariables['release_notification_list'] = "${phaseNotificationDg_prod}"
        else:
             releaseVariables['release_notification_list'] = "please_configure_some_email@domain.com"

        phase_certified_artifact_version_name="phase_certified_artifact_version"+str(component_name)
        phase_certified_artifact_property_name="phase_certified_artifact_property"+str(component_name)

        try:
            releaseVariables['phase_certified_artifact_version']=releaseVariables[phase_certified_artifact_version_name]
            releaseVariables['phase_certified_artifact_property']=releaseVariables[phase_certified_artifact_property_name]
        except:
            releaseVariables['phase_certified_artifact_version']=""
            releaseVariables['phase_certified_artifact_property']=""
    - name: Update release name
      type: xlrelease.ScriptTask
      script: |-
        current_release = getCurrentRelease()

        if ("${jenkinsBuildNo}"):
            current_release.title = "{0} Build#{1} {2}".format("${original_release_title}","${jenkinsBuildNo}","${delivery_environment_name}")
        else:
            current_release.title = "{0} {1}".format("${original_release_title}","${delivery_environment_name}")

        releaseApi.updateRelease(current_release)
    - name: Acknowledge/sign off release code quality metrics
      type: xlrelease.SequentialGroup
      precondition: "releaseVariables['enable_sonar_metrics_check'] == 'Yes'"
      tags:
      - key_process_step
      tasks:
      - name: Delete Existing SonarQube token
        type: webhook.JsonWebhook
        URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
        method: POST
        username: "${global.cross_connect_userid}"
        variableMapping:
          pythonScript.password: "${global.cross_connect_password}"
      - name: Generate SonarQube token
        type: webhook.JsonWebhook
        URL: "${global.sonarurl}/api/user_tokens/generate?name=${spkComponentsToRelease}"
        method: POST
        username: "${global.cross_connect_userid}"
        jsonPathExpression: $.token
        variableMapping:
          pythonScript.result: "${SonarQube_token}"
          pythonScript.password: "${global.cross_connect_password}"
      - name: "Reading SonarQube Metrics for  ${sonarComponentKey}"
        type: xlrelease.ScriptTask
        script: |-
          import urllib2
          import json
          import base64

          # defining the api-endpoint

          url="${global.sonarurl}/api/measures/component?componentKey=${sonarComponentKey}&metricKeys=alert_status,bugs,blocker_violations,critical_violations,vulnerabilities,code_smells,duplicated_blocks,duplicated_lines_density,ncloc"

          print("URL....", url)

          token = releaseVariables['SonarQube_token'] + ":"
          encodedToken =  base64.encodestring(token).rstrip('\n')
          print ("Encodedtoken= ", encodedToken)

          req=urllib2.Request(url=url)
          req.add_header('Authorization', "Basic %s" % encodedToken)
          req.add_header("Content-Type", "application/json")

          jobResponse=urllib2.urlopen(req).read()

          print("JOB Response", jobResponse)

          json_data = json.loads(jobResponse)

          print ("\n JSON DATA....",json_data)

          metrics_data = {}
          for item in json_data['component']['measures']:
              metrics_data[item['metric']] = item['value']

          releaseVariables['sonarqube_bugs']  = int(metrics_data.get('bugs'))

          releaseVariables['sonarqube_blocker_violations']  = int(metrics_data.get('blocker_violations'))

          releaseVariables['sonarqube_critical_violations']  = int(metrics_data.get('critical_violations'))
          releaseVariables['sonarqube_vulnerabilities'] = int(metrics_data.get('vulnerabilities'))
          releaseVariables['sonarqube_code_smells'] = int(metrics_data.get('code_smells'))
          releaseVariables['sonarqube_duplicated_blocks'] = int(metrics_data.get('duplicated_blocks'))
          releaseVariables['sonarqube_duplicated_lines_density'] = metrics_data.get('duplicated_lines_density')
          releaseVariables['sonarqube_ncloc'] = int(metrics_data.get('ncloc'))

          gg = metrics_data.get('alert_status')

          if gg == "OK":
              releaseVariables['sonarqube_quality_gate'] = "PASSED"

          if gg == "ERROR":
             releaseVariables['sonarqube_quality_gate'] = "FAILED"
      - name: Delete SonarQube token
        type: webhook.JsonWebhook
        URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
        method: POST
        username: "${global.cross_connect_userid}"
        variableMapping:
          pythonScript.password: "${global.cross_connect_password}"
      - name: Sign off on SonarQube metrics for the release
        type: xlrelease.GateTask
        description: |-
          - Quality Gate :  ${sonarqube_quality_gate}
          - Bugs: ${sonarqube_bugs}
          - Blocker Violations: ${sonarqube_blocker_violations}
          - Critical Violations: ${sonarqube_critical_violations}
          - Vulnerabilities: ${sonarqube_vulnerabilities}
          - Code Smells: ${sonarqube_code_smells}
          - Duplicated Blocks: ${sonarqube_duplicated_blocks}
          - Duplicated Line Density: ${sonarqube_duplicated_lines_density}
          - Lines of Code: ${sonarqube_ncloc}
        tags:
        - key_process_step
    - name: Pre-tasks for DMZ deployment
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Validate Inventory configured in tower Job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${towerDeployerIdProd}"
        jsonPathExpression: $..inventory
        variableMapping:
          pythonScript.result: "${ansible_template_inventory_name}"
          pythonScript.password: "${towerDeployerPasswordProd}"
      - name: Get Inventory name from Tower Job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${towerDeployerIdProd}"
        jsonPathExpression: "results[0].summary_fields.inventory.name"
        precondition: "releaseVariables['ansible_template_inventory_name']!=\"[null]\""
        variableMapping:
          pythonScript.result: "${tower_job_inventory_name}"
          pythonScript.password: "${towerDeployerPasswordProd}"
      - name: Validate inventory
        type: xlrelease.ScriptTask
        script: |-
          if releaseVariables['ansible_template_inventory_name']!='[null]' and releaseVariables['xlr_inventory_name']!="":
              if releaseVariables['tower_job_inventory_name'] == releaseVariables['xlr_inventory_name']:
                  print "Inventory name in XLR and Tower are same, Good to go!"
              elif releaseVariables['tower_job_inventory_name'] != releaseVariables['xlr_inventory_name']:
                 print """Ansible tower job_template '${ansible_tower_job_template_name}' is not correctly configured to accept an inventory as input \n Please remove inventory name and update the tower job_template with ('prompt on launch')"""
                 sys.exit(1)
          elif releaseVariables['ansible_template_inventory_name']=='[null]' and releaseVariables['xlr_inventory_name']=="":
              print "Ansible tower job_template '${ansible_tower_job_template_name}'is not configured with an inventory name, please configure valid inventory name"
              sys.exit(1)
          print "Validation looks Good !"
      - name: Construct Instance group url  from ansible Job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${towerDeployerIdProd}"
        jsonPathExpression: "results[0].related.instance_groups"
        variableMapping:
          pythonScript.password: "${towerDeployerPasswordProd}"
          pythonScript.result: "${ansible_tower_job_template_instance_group_url}"
      - name: Get Instance group details from instance group url
        type: webhook.JsonWebhook
        URL: "${global.ansible-prod-towerurl}${ansible_tower_job_template_instance_group_url}"
        username: "${towerDeployerIdProd}"
        jsonPathExpression: results
        variableMapping:
          pythonScript.result: "${ansible_tower_instance_group_from_template}"
          pythonScript.password: "${towerDeployerPasswordProd}"
      - name: Get Ansible inventory id from XLR template
        type: webhook.JsonWebhook
        URL: "${global.ansible-prod-towerurl}/api/v2/inventories?name=${xlr_inventory_name}"
        username: "${towerDeployerIdProd}"
        jsonPathExpression: "results[0].id"
        precondition: "releaseVariables['xlr_inventory_name'] !=\"\""
        variableMapping:
          pythonScript.result: "${ansible_tower_job_inventory}"
          pythonScript.password: "${towerDeployerPasswordProd}"
      - name: Get Inventory id from ansible job template
        type: webhook.JsonWebhook
        URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${towerDeployerIdProd}"
        jsonPathExpression: "results[0].summary_fields.inventory.id"
        precondition: "releaseVariables['xlr_inventory_name'] ==\"\""
        variableMapping:
          pythonScript.result: "${ansible_tower_job_inventory}"
          pythonScript.password: "${towerDeployerPasswordProd}"
      - name: Get Ansible Instance group from inventory id
        type: webhook.JsonWebhook
        URL: "${global.ansible-prod-towerurl}/api/v2/inventories/${ansible_tower_job_inventory}/instance_groups"
        username: "${towerDeployerIdProd}"
        jsonPathExpression: results
        variableMapping:
          pythonScript.password: "${towerDeployerPasswordProd}"
          pythonScript.result: "${ansible_tower_instance_group}"
      - name: "Determine Artifactory : DMZ or Baronet"
        type: xlrelease.ScriptTask
        script: |-
          releaseVariables['deployDMZ_prod']="No"
          releaseVariables['ansible_tower_job_inventory_id']=0
          jobtemplate_deploydmz ="No"
          inventory_deploydmz = "No"
          instance_group_match ="No"
          if releaseVariables['xlr_inventory_name'] =="":
              releaseVariables['ansible_tower_job_inventory_id']=0
          elif releaseVariables['xlr_inventory_name'] !="":
              releaseVariables['ansible_tower_job_inventory_id'] = int (releaseVariables['ansible_tower_job_inventory'])
          print ("Inventory_id passing from XLR to Tower job template =>",releaseVariables['ansible_tower_job_inventory_id'])

          if "ztwr" in releaseVariables['ansible_tower_instance_group']:
              inventory_deploydmz="Yes"
          elif "ztwr" not in releaseVariables['ansible_tower_instance_group']:
              inventory_deploydmz="No"
          if inventory_deploydmz =="No":
              if "ztwr" not in releaseVariables['ansible_tower_instance_group'] and releaseVariables['ansible_tower_instance_group'] !="[]":
                  inventory_instance_grp = "Yes"
              elif releaseVariables['ansible_tower_instance_group'] =="[]":
                  inventory_instance_grp = "No"
              print ("inventory_instance_grp==>", inventory_instance_grp)

          if "ztwr" in releaseVariables['ansible_tower_instance_group_from_template']:
              jobtemplate_deploydmz="Yes"
          elif "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template']:
              jobtemplate_deploydmz = "No"

          if jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="Yes":
              print """Instance group in inventory configured with non-DMZ but instance group in tower job template configured with DMZ \n Always job template instance group take precedence, so please configure your Tower job template properly"""
              sys.exit(1)
          elif jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="No":
              releaseVariables['deployDMZ_prod'] = "Yes"
          elif jobtemplate_deploydmz == "Yes" and inventory_deploydmz=="Yes":
              if "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              elif "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              elif "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              elif "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                  instance_group_match = "Yes"
              if instance_group_match == "Yes":
                  releaseVariables['deployDMZ_prod'] = "Yes"
              else:
                  print """DMZ instance group configured in inventory does not match with DMZ instance group configured in job template...\n Please configure them correctly!!"""
                  sys.exit(1)

          if jobtemplate_deploydmz=="No":
              if "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template'] and releaseVariables['ansible_tower_instance_group_from_template'] !="[]":
                  template_instance_grp = "Yes"
              elif releaseVariables['ansible_tower_instance_group_from_template'] =="[]":
                  template_instance_grp = "No"
              print ("template_instance_grp==>", template_instance_grp)
              if template_instance_grp == "Yes" and inventory_deploydmz=="Yes":
                  print """Your inventory's instance group configured with DMZ But Your job template's instance group not configured with DMZ. \n Always job template instance group take precedence, so please configure your Tower job template properly"""
                  releaseVariables['deployDMZ_prod'] = "No"
                  sys.exit(1)
              elif template_instance_grp == "No" and inventory_deploydmz=="Yes":
                  releaseVariables['deployDMZ_prod'] = "Yes"
              elif template_instance_grp == "No" and inventory_deploydmz=="No":
                  releaseVariables['deployDMZ_prod'] = "No"
          print ("inventory_dmz==>", inventory_deploydmz)
          print ("jobtemplate_dmz==>", jobtemplate_deploydmz)
          print("<-------------------deployDMZ---------->", releaseVariables['deployDMZ_prod'])
    - name: Get build artifact version (s) to deploy
      type: xlrelease.SequentialGroup
      tasks:
      - name: Artifactory API key generation
        type: xlrelease.SequentialGroup
        description: '### This task will generate encrypted API key that can be used
          in the fetch artifact version script tasks of this release template'
        tasks:
        - name: GET
          type: webhook.JsonWebhook
          URL: "${global.artifactoryurl}/api/security/apiKey"
          username: "${global.cross_connect_userid}"
          jsonPathExpression: $.apiKey
          variableMapping:
            pythonScript.result: "${ArtifactoryAPIkey}"
            pythonScript.password: "${global.cross_connect_password}"
      - name: Get build artifact's Release Candidate Version
        type: xlrelease.ScriptTask
        description: "#### This task will get latest version of the build artifact\
          \  ####"
        script: |-
          import urllib2
          import json

          artifactoryUrl="${global.artifactoryurl}/api/search/aql"
          certification_history = ""

          data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
          artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
          artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
          artifactoryRequest.add_header("Content-Type", "text/plain")
          artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
          artifactData = json.loads(artifactoryResponse)

          myprop={}
          for i in xrange(len(artifactData["results"])):
              for j in xrange(len(artifactData["results"][i]["properties"])):
                  if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                      releaseVariables["artifact_build_version_ciurl_var"]=artifactData["results"][i]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]
                      myprop=artifactData["results"][i]["properties"]

          for i in xrange(len(myprop)):
              if (myprop[i]["key"] == "build.number"):
                  releaseVariables["artifact_build_version_buildnum_var"]=myprop[i]["value"]
              if (myprop[i]["key"] == "ait.number"):
                  releaseVariables["artifact_build_version_ait_var"]=myprop[i]["value"]
              if (myprop[i]["key"] == "scm.location"):
                  releaseVariables["artifact_build_version_scmloc_var"]=myprop[i]["value"]
              if (myprop[i]["key"] == "scm.branch"):
                  releaseVariables["artifact_build_version_scmbranch_var"]=myprop[i]["value"]
              if ("Certified" in myprop[i]["key"]):
                  certification_history="\n\n" + myprop[i]["key"] + "=" + myprop[i]["value"]+"\n\n"+certification_history

          releaseVariables["artifactory_certification_history"]=certification_history

          data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",releaseVariables["artifact_build_version_buildnum_var"])
          artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
          artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
          artifactoryRequest2.add_header("Content-Type", "text/plain")
          jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
          artifactData2 = json.loads(jobResponse2)

          mylist=""
          for index in range(len(artifactData2["results"])):
              data_url="https://artifacts.customer.domain.com/artifactory"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
              if(mylist==""):
                  mylist=data_url
              else:
                  mylist=mylist+","+data_url

          if ',' in mylist:
              mylist=mylist.replace(",","', '")
              mylist= "['"+mylist+"']"

          releaseVariables["artifact_build_version_artifactoryUrl"] = mylist


          releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"
          releaseVariables["old_artifact_build_version_artifactoryUrl"]=releaseVariables["artifact_build_version_artifactoryUrl"]
          releaseVariables["old_artifact_build_version_buildnum_var"]=releaseVariables["artifact_build_version_buildnum_var"]
    - name: Ensure production change readiness
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Confirm target release CRQ number
        type: xlrelease.UserInputTask
        description: '#### Please confirm CRQ number of this release'
        tags:
        - key_process_step
        variables:
        - target_release_crq_number
      - name: "Get current status of ${target_release_crq_number}"
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
        script: |-
          import urllib2
          import json
          import time
          import base64

          url="${global.remedyurl}/security/issueToken?servicename=changeservice"

          req=urllib2.Request(url=url,data="")

          req.add_header("Content-Type", "application/x-www-form-urlencoded")
          req.add_header("userName", "ZS30SW4")
          req.add_header("password", base64.b64decode("cndralMyWXE="))

          Token=urllib2.urlopen(req).read()


          # defining the api-endpoint
          url="${global.remedyurl}/api/changequery/get_changecore/${target_release_crq_number}"

          req1=urllib2.Request(url=url)
          req1.add_header("Authorization", Token)
          req1.add_header("Content-Type", "application/json")

          jobResponse=urllib2.urlopen(req1).read()
          jsonData = json.loads(jobResponse)
          status = jsonData['status']
          releaseVariables["CRQStatus"]=status
          print(releaseVariables["CRQStatus"])

          # Getting Release-id
          releaseId = "${release.id}"
          id = releaseId.replace('/','-').replace("Applications-","/#/releases/")
          releaseVariables['xlr_url'] = "${global.xlrurl}"+id
          print("\n \n xlr_url =" , releaseVariables['xlr_url'])
      - name: "Update ${target_release_crq_number} work info w/ delivery pipeline\
          \ status"
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
        script: |-
          import urllib2
          import json
          import time
          import base64

          url="${global.remedyurl}/security/issueToken?servicename=changeservice"

          req=urllib2.Request(url=url,data="")

          req.add_header("Content-Type", "application/x-www-form-urlencoded")
          req.add_header("userName", "ZS30SW4")
          req.add_header("password", base64.b64decode("cndralMyWXE="))

          Token=urllib2.urlopen(req).read()



          # defining the api-endpoint
          url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


          transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

          transId ="XLR_Add_Worklog_"+str(transaction_datetime)

          # sourceReqId is obtained from Remedy (its constant and wont change for every call)
          #sourceReqId = 'XLR_GWB_CHANGE_002'

          print("transaction ID:", transId)

          json1={
              "transactionDetails": {
              "transactionType": "ADDWORKLOG",
              "transactionId": transId,
              "eventSource": "XLR_GWB_CHANGE",
              "sourceRequestId": "XLR_GWB_CHANGE",
              "eventTarget": "BAC_CHANGE",
              "targetRequestId": "${target_release_crq_number}",
              "transactionDate": transaction_datetime
            },
            "updateSystemManaged": {
              "personIdType": "LoginName",
              "createdBy": "${xlr_remedy_workinfo_creator}"
            },
            "changeWorkInfo": {
              "workLogId": "",
              "workLogType": "General Information",
              "workLogNotes": "${spkName} has been successfully deployed, tested & certified in DEV & LLE environments  \n\nDeployed artifacts:  ${artifact_build_version_artifactorybrowseUrl} \n\nFor further details on this release, check delivery pipeline ${delivery_pipeline_url}",
              "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
              "workLogAccess": "Public"
             }
          }

          print(json1)

          # data to be sent to api
          data=json.dumps(json1)

          req1=urllib2.Request(url=url2,data=data)

          req1.add_header("Authorization", Token)
          req1.add_header("Content-Type", "application/json")
          req1.get_method = lambda : 'PUT'

          response=urllib2.urlopen(req1).read()
          message = json.loads(response)
          print(message)
      - name: "Update ${target_release_crq_number} work info w/ Install Plan"
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
        script: |-
          import urllib2
          import json
          import time
          import base64

          url="${global.remedyurl}/security/issueToken?servicename=changeservice"

          req=urllib2.Request(url=url,data="")

          req.add_header("Content-Type", "application/x-www-form-urlencoded")
          req.add_header("userName", "ZS30SW4")
          req.add_header("password", base64.b64decode("cndralMyWXE="))

          Token=urllib2.urlopen(req).read()



          # defining the api-endpoint
          url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


          transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

          transId ="XLR_Add_Worklog_"+str(transaction_datetime)

          # sourceReqId is obtained from Remedy (its constant and wont change for every call)
          #sourceReqId = 'XLR_GWB_CHANGE_002'

          print("transaction ID:", transId)

          json1={
              "transactionDetails": {
              "transactionType": "ADDWORKLOG",
              "transactionId": transId,
              "eventSource": "XLR_GWB_CHANGE",
              "sourceRequestId": "XLR_GWB_CHANGE",
              "eventTarget": "BAC_CHANGE",
              "targetRequestId": "${target_release_crq_number}",
              "transactionDate": transaction_datetime
            },
            "updateSystemManaged": {
              "personIdType": "LoginName",
              "createdBy": "${xlr_remedy_workinfo_creator}"
            },
            "changeWorkInfo": {
              "workLogId": "",
              "workLogType": "Install Plan",
              "workLogNotes": "${spkName} change will be deployed to production by Horizon CD pipeline (in XLR). Details on steps being executed can be found here :- ${delivery_pipeline_url}",
              "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
              "workLogAccess": "Public"
             }
          }

          print(json1)

          # data to be sent to api
          data=json.dumps(json1)

          req1=urllib2.Request(url=url2,data=data)

          req1.add_header("Authorization", Token)
          req1.add_header("Content-Type", "application/json")
          req1.get_method = lambda : 'PUT'

          response=urllib2.urlopen(req1).read()
          message = json.loads(response)
          print(message)
      - name: "Update ${target_release_crq_number} work info w/ Test Plan"
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
        script: |-
          import urllib2
          import json
          import time
          import base64

          url="${global.remedyurl}/security/issueToken?servicename=changeservice"

          req=urllib2.Request(url=url,data="")

          req.add_header("Content-Type", "application/x-www-form-urlencoded")
          req.add_header("userName", "ZS30SW4")
          req.add_header("password", base64.b64decode("cndralMyWXE="))

          Token=urllib2.urlopen(req).read()



          # defining the api-endpoint
          url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


          transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

          transId ="XLR_Add_Worklog_"+str(transaction_datetime)

          # sourceReqId is obtained from Remedy (its constant and wont change for every call)
          #sourceReqId = 'XLR_GWB_CHANGE_002'

          print("transaction ID:", transId)

          json1={
              "transactionDetails": {
              "transactionType": "ADDWORKLOG",
              "transactionId": transId,
              "eventSource": "XLR_GWB_CHANGE",
              "sourceRequestId": "XLR_GWB_CHANGE",
              "eventTarget": "BAC_CHANGE",
              "targetRequestId": "${target_release_crq_number}",
              "transactionDate": transaction_datetime
            },
            "updateSystemManaged": {
              "personIdType": "LoginName",
              "createdBy": "${xlr_remedy_workinfo_creator}"
            },
            "changeWorkInfo": {
              "workLogId": "",
              "workLogType": "Test Plan",
              "workLogNotes": "${spkName} change will be tested in an automated fashion by litmus and executed by Horizon CD pipeline (in XLR). Details on test results, signoffs etc can be found here :- ${delivery_pipeline_url}",
              "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
              "workLogAccess": "Public"
             }
          }

          print(json1)

          # data to be sent to api
          data=json.dumps(json1)

          req1=urllib2.Request(url=url2,data=data)

          req1.add_header("Authorization", Token)
          req1.add_header("Content-Type", "application/json")
          req1.get_method = lambda : 'PUT'

          response=urllib2.urlopen(req1).read()
          message = json.loads(response)
          print(message)
      - name: "Update ${target_release_crq_number} work info w/ Backout Plan"
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
        script: |-
          import urllib2
          import json
          import time
          import base64

          url="${global.remedyurl}/security/issueToken?servicename=changeservice"

          req=urllib2.Request(url=url,data="")

          req.add_header("Content-Type", "application/x-www-form-urlencoded")
          req.add_header("userName", "ZS30SW4")
          req.add_header("password", base64.b64decode("cndralMyWXE="))

          Token=urllib2.urlopen(req).read()



          # defining the api-endpoint
          url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


          transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

          transId ="XLR_Add_Worklog_"+str(transaction_datetime)

          # sourceReqId is obtained from Remedy (its constant and wont change for every call)
          #sourceReqId = 'XLR_GWB_CHANGE_002'

          print("transaction ID:", transId)

          json1={
              "transactionDetails": {
              "transactionType": "ADDWORKLOG",
              "transactionId": transId,
              "eventSource": "XLR_GWB_CHANGE",
              "sourceRequestId": "XLR_GWB_CHANGE",
              "eventTarget": "BAC_CHANGE",
              "targetRequestId": "${target_release_crq_number}",
              "transactionDate": transaction_datetime
            },
            "updateSystemManaged": {
              "personIdType": "LoginName",
              "createdBy": "${xlr_remedy_workinfo_creator}"
            },
            "changeWorkInfo": {
              "workLogId": "",
              "workLogType": "Backout Plan",
              "workLogNotes": "${spkName} change backout can be performed from the Horizon CD pipeline (in XLR) itself (manually by doing a restart on PROD phases and directing it to deploy a specific version to Production environments that the team decides to roll it back to) . Details on pipeline execution can be found here :- ${delivery_pipeline_url}",
              "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
              "workLogAccess": "Public"
             }
          }

          print(json1)

          # data to be sent to api
          data=json.dumps(json1)

          req1=urllib2.Request(url=url2,data=data)

          req1.add_header("Authorization", Token)
          req1.add_header("Content-Type", "application/json")
          req1.get_method = lambda : 'PUT'

          response=urllib2.urlopen(req1).read()
          message = json.loads(response)
          print(message)
      - name: "Send an email to the release team to ensure ${target_release_crq_number}\
          \ readiness"
        type: xlrelease.NotificationTask
        precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
        tags:
        - key_process_step
        addresses:
        - "${release_notification_list}"
        subject: "Review CRQ ${target_release_crq_number}"
        body: |-
          - Current status of ${target_release_crq_number} :  ${CRQStatus}
          - Please review [${target_release_crq_number}](
          ${global.itsmurl}${target_release_crq_number}) for completeness and work with your change coordinators in getting necessary approvals.
          - Please make sure CRQ is put into "Scheduled" state for the deployment to begin
      - name: "Send an email to the release team to ensure ${target_release_crq_number}\
          \ readiness"
        type: xlrelease.NotificationTask
        precondition: "releaseVariables['remedyEnableIntegration'] == 'No'"
        tags:
        - key_process_step
        addresses:
        - "${release_notification_list}"
        subject: "Review CRQ ${target_release_crq_number}"
        body: |-
          - Please review [${target_release_crq_number}](
          ${global.itsmurl}${target_release_crq_number})for completeness and work with your change coordinators in getting necessary approvals.
          - Please make sure CRQ is put into "Scheduled" state for the deployment to begin
    - name: Production change go/no-go
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Production Go/No Go Decision?
        type: xlrelease.GateTask
        description: |-
          #### Hello Release Manager Team :-

          Is ${target_release_crq_number} approved and ready to go to Production?
        tags:
        - key_process_step
        conditions:
        - name: "Yes, ${target_release_crq_number} is in scheduled state and good\
            \ to go"
          type: xlrelease.GateCondition
      - name: "Get current status of ${target_release_crq_number}"
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
        script: |-
          import urllib2
          import json
          import time
          import base64

          url="${global.remedyurl}/security/issueToken?servicename=changeservice"

          req=urllib2.Request(url=url,data="")

          req.add_header("Content-Type", "application/x-www-form-urlencoded")
          req.add_header("userName", "ZS30SW4")
          req.add_header("password", base64.b64decode("cndralMyWXE="))

          Token=urllib2.urlopen(req).read()




          # defining the api-endpoint
          url="${global.remedyurl}/api/changequery/get_changecore/${target_release_crq_number}"

          req1=urllib2.Request(url=url)
          req1.add_header("Authorization", Token)
          req1.add_header("Content-Type", "application/json")

          jobResponse=urllib2.urlopen(req1).read()
          jsonData = json.loads(jobResponse)
          status = jsonData['status']
          releaseVariables["CRQStatus"]=status
          print(releaseVariables["CRQStatus"])

          # Getting Release-id
          releaseId = "${release.id}"
          id = releaseId.replace('/','-').replace("Applications-","/#/releases/")
          releaseVariables['xlr_url'] = "${global.xlrurl}"+id
          print("\n \n xlr_url =" , releaseVariables['xlr_url'])
      - name: Final confirmation on production change
        type: xlrelease.GateTask
        description: |-
          #### ** Hey Release Manager Team :- **  ####

          Please provide final confirmation on this production change.

          - Change : ${target_release_crq_number}
          - Status =  ${CRQStatus}
        precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
        tags:
        - key_process_step
        conditions:
        - name: "Looks right, OK to proceeed !"
          type: xlrelease.GateCondition
    - name: Deployment approval by Deployer PROD team
      type: xlrelease.UserInputTask
      description: |-
        #### Hello Deployer ${delivery_environment_type} Team :-
        ${phase_certified_artifact_property} ${phase_certified_artifact_version}

        Tower job template ${ansible_tower_job_template_name} will deploy the following build to ${delivery_environment_name}

        ${artifact_build_version_artifactorybrowseUrl}

        Certification History:
        ${artifactory_certification_history}

        Click "Complete" to to kick off deployment job in tower
      tags:
      - key_process_step
      variables:
      - artifact_build_version_artifactoryUrl
      - artifact_build_version_buildnum_var
      - towerDeployerIdProd
      - towerDeployerPasswordProd
    - name: Deploy application changes/build
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: Construct artifactory url for deployment
        type: xlrelease.ScriptTask
        description: "#### This task will get latest version of the build artifact\
          \  ####"
        script: |-
          import urllib2
          import json

          artifactoryUrl="${global.artifactoryurl}/api/search/aql"
          myNewUrl="${artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
          myNewUrl=myNewUrl.replace("webapp/#/artifacts/browse/tree/General/","")
          myNewUrl=myNewUrl.replace("${artifactoryBuildRepo}/","")
          myNewUrl=myNewUrl.replace("[","")
          myNewUrl=myNewUrl.replace("]","")
          myNewUrl=myNewUrl.replace("'","")
          myNewUrlList=myNewUrl.split(",")


          myOldUrl="${old_artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
          myOldUrl=myOldUrl.replace("webapp/#/artifacts/browse/tree/General/","")
          myOldUrl=myOldUrl.replace("${artifactoryBuildRepo}/","")
          myOldUrl=myOldUrl.replace("[","")
          myOldUrl=myOldUrl.replace("]","")
          myOldUrl=myOldUrl.replace("'","")
          myOldUrlList=myOldUrl.split(",")

          releaseVariables["isReleaseCandidate"]="No"

          def GetFinalArtifactUrlList(buildNumber):
              data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %("${artifactoryBuildRepo}","${artifactoryBuildName}",buildNumber)
              artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
              artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest2.add_header("Content-Type", "text/plain")
              jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
              artifactData2 = json.loads(jobResponse2)

              mylist=""
              for index in range(len(artifactData2["results"])):
                  data_url="${global.artifactoryurl}"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                  if(mylist==""):
                      mylist=data_url
                  else:
                      mylist=mylist+","+data_url

              if ',' in mylist:
                  mylist=mylist.replace(",","', '")
                  mylist= "['"+mylist+"']"

              releaseVariables["artifact_build_version_artifactoryUrl"] = mylist
              releaseVariables["artifact_build_version_path_var"]=artifactData2["results"][index]["path"]
              releaseVariables["artifact_build_version_name_var"]=artifactData2["results"][index]["name"]

          def GetFinalArtifactData(myPathName,myArtifactName):
              data1="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"path\":{\"$match\":\"%s\"}},{\"name\":{\"$match\":\"%s\"}}).include(\"name\",\"repo\",\"path\",\"created\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",myPathName,myArtifactName)
              artifactoryRequest1=urllib2.Request(url=artifactoryUrl,data=data1)
              artifactoryRequest1.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest1.add_header("Content-Type", "text/plain")
              jobResponse1=urllib2.urlopen(artifactoryRequest1).read()
              artifactData1 = json.loads(jobResponse1)

              releaseVariables["artifact_build_version_ciurl_var"]=artifactData1["results"][0]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]

              for i in xrange(len(artifactData1["results"][0]["properties"])):
                  if (artifactData1["results"][0]["properties"][i]["key"] == "ait.number"):
                      releaseVariables["artifact_build_version_ait_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "scm.location"):
                      releaseVariables["artifact_build_version_scmloc_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "build.number"):
                      releaseVariables["artifact_build_version_buildnum_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "scm.branch"):
                      releaseVariables["artifact_build_version_scmbranch_var"]=artifactData1["results"][0]["properties"][i]["value"]
                  if (artifactData1["results"][0]["properties"][i]["key"] == "${release_candidate_name}-Certified" and artifactData1["results"][0]["properties"][i]["value"] == "Yes"):
                      releaseVariables["isReleaseCandidate"]="Yes"


          if "${old_artifact_build_version_buildnum_var}" != "${artifact_build_version_buildnum_var}":
              GetFinalArtifactUrlList("${artifact_build_version_buildnum_var}")
              GetFinalArtifactData(releaseVariables["artifact_build_version_path_var"],releaseVariables["artifact_build_version_name_var"])
              if (releaseVariables["isReleaseCandidate"] == "No"):
                  print 'The details entered does not correspond to a release candidate build.'
                  sys.exit(1)
          elif myNewUrlList[0] not in myOldUrlList:
              myNewUrl=myNewUrlList[0].rsplit('/', 1)
              GetFinalArtifactData(myNewUrl[0],myNewUrl[1])
              if (releaseVariables["isReleaseCandidate"] == "No"):
                  print 'The details entered does not correspond to a release candidate build.'
                  sys.exit(1)


          releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"

          ### Set Deployment Dashboard parameters

          spkName = "${spkName}".upper().strip()
          delivery_environment_name = "${delivery_environment_name}".upper().strip()
          dashboard_delivery_environment_name = spkName + "-" + delivery_environment_name
          releaseVariables['dashboard_delivery_environment_name'] = dashboard_delivery_environment_name

          # ID
          dashboard_deployerId = str(dashboard_delivery_environment_name) + "-deployerId"
          releaseVariables[dashboard_deployerId] = "${towerDeployerIdProd}"
          ###XLR DMZ Integration
          if releaseVariables['deployDMZ_prod']=="Yes":
                  releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl'].replace("${global.artifactoryurl}","${global.dmzArtifactoryUrl_Prod}")
          else:
              releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl']
          print("deployDMZ_prod==", releaseVariables['deployDMZ_prod'])
          print("Artifactory URL==", releaseVariables['published_artifact_url'])
      - name: Get job template id
        type: webhook.JsonWebhook
        URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
        username: "${towerDeployerIdProd}"
        jsonPathExpression: "results[0].id"
        variableMapping:
          pythonScript.result: "${ansible_tower_job_template_id}"
          pythonScript.password: "${towerDeployerPasswordProd}"
      - name: "Deploy ${artifactoryBuildName}"
        type: ansible.LaunchJobTemplate
        username: "${towerDeployerIdProd}"
        jobTemplate: "${ansible_tower_job_template_id}"
        description: "## Deploy ${artifactoryBuildName}"
        facets:
        - type: udm.DeploymentTaskFacet
          variableMapping:
            environmentId: "${dashboard_delivery_environment_name}"
            applicationId: "${component_name}"
            version: "${artifact_build_version_buildnum_var}"
        variableMapping:
          pythonScript.jobId: "${ansible_job_id}"
          pythonScript.password: "${towerDeployerPasswordProd}"
          pythonScript.inventory: "${ansible_tower_job_inventory_id}"
        tags:
        - key_process_step
      - name: Fetch ansible job log
        type: xlrelease.ScriptTask
        description: "#### This task will get latest version of the build artifact\
          \  ####"
        script: "releaseVariables[\"ansible_tower_job_url\"]=\"${global.ansible-prod-towerurl}/#/jobs/${ansible_job_id}\""
    - name: Kick off litmus tests
      type: xlrelease.SequentialGroup
      precondition: "\"${litmus_enable_automated_tests}\".lower() == \"yes\""
      tags:
      - key_process_step
      tasks:
      - name: Validate LitmusTest input
        type: xlrelease.ScriptTask
        script: |-
          val = "${artifact_build_version_ait_var}"
          if not val: raise ValueError("ait_number is mandatory parameter for LitmusTest execution.")

          val = "${litmus_test_component}"
          if not val: raise ValueError("litmusComponentName is mandatory parameter for LitmusTest execution. Please fill it with valid value for your environment.")

          val = "${litmus_test_url}"
          if not val: raise ValueError("litmusTargetApplicationUrl is mandatory parameter for LitmusTest execution.Please fill it with valid value for your environment.")

          val = "${litmus_spk}"
          if not val: raise ValueError("litmus_spk is mandatory parameter for LitmusTest execution.")

          releaseVariables['litmus_input_validated'] = True
      - name: Submit Litmus Request
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['litmus_input_validated'] == True"
        script: |-
          import urllib2
          import json
          import datetime
          import sys

          payload = {
            "BuildRunID": "" ,
            "AIT": "${artifact_build_version_ait_var}",
            "SPK": "${litmus_spk}",
            "JobStatus": "New",
            "DeployedDate": str(datetime.datetime.now()),
            "TestPhase": "${litmus_phase}",
            "ApplicationURL": "${litmus_app_url}",
            "EnvironmentName": "${delivery_environment_name}",
            "Component": "${litmus_test_component}",
            "Requestor":"XLR"
          }
          print("Req to be submitted to LitmusTest is - \n")
          print(payload)

          # Send req to Litmus
          data=json.dumps(payload)

          baseURL = "${litmus_test_url}"
          if not baseURL.endswith("/"):
              baseURL = baseURL +"/"
          url = baseURL+"LitmusTest/InsertEvent"

          req=urllib2.Request(url=url ,data=data)
          req.add_header("Content-Type", "application/json")
          response=urllib2.urlopen(req).read()
          message = json.loads(response)
          print("\nResponse received-\n")
          print(message)
          requestStatus = message["requestStatus"]
          releaseVariables['litmus_request_id'] = message["requestId"]
          if requestStatus == "Request has been successfully queued.":
            releaseVariables['req_submitted'] = True
            print("\nRequest has been submitted to LitmusTest with requestId - "+ str(message["requestId"]))
          else:
              print("\nRequest could not be submitted to LitmusTest.\n")
              print (requestStatus)
              print("\n")
              sys.exit(1)
      - name: Process Response
        type: xlrelease.SequentialGroup
        precondition: "releaseVariables['req_submitted'] == True"
        tasks:
        - name: Process Smoke Test Response
          type: xlrelease.ScriptTask
          script: |-
            import json
            import urllib2
            import time
            import sys

            payload = {
                "requestId":${litmus_request_id}
            }

            # Send req to Litmus for status check
            data = json.dumps(payload)
            baseURL = "${litmus_test_url}"
            if not baseURL.endswith("/"):
                baseURL = baseURL + "/"
            url = baseURL + "LitmusTest/GetRequestStatus"

            timePassed = 0
            timeoutOccured = True
            while (timePassed < int(${litmus_smoke_timeout})):
                time.sleep(${litmus_polling_interval})
                timePassed = timePassed + ${litmus_polling_interval}

                req = urllib2.Request(url=url, data=data)
                req.add_header("Content-Type", "application/json")
                response = urllib2.urlopen(req).read()
                message = json.loads(response)

                executingStatus = message["executingStatus"]
                returnCode = message["executingState"]
                index = returnCode.find("(")
                shortCode = returnCode
                if index != -1:
                    shortCode = returnCode[:returnCode.find("(")]
                shortCode = shortCode.lower()

                if (executingStatus == 'Waiting' or executingStatus == 'Smoke Executing'):
                    continue
                print(message)
                print("\n")
                print("\n")
                timeoutOccured = False
                executionDetails = message["executionDetails"]
                if (executingStatus.__contains__("Executing")):
                    if (shortCode == "smoke_pass1"):
                        print("\nSmoke Test passed, Basic Test is scheduled.")
                        releaseVariables['litmus_process_basic'] = True
                    elif (shortCode == "smoke_pass2"):
                        print("\nSmoke Passed, Regression Test is scheduled")
                        releaseVariables['litmus_process_regression'] = True
                    elif (shortCode == "basic_pass"):
                        print("\nBasic Passed, Regression Test is scheduled")
                        releaseVariables['litmus_process_regression'] = True
                    else:
                        print("\nInvalid executing state received.\n")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                    print("\nTest execution summary- ")
                    for eDetail in executionDetails:
                        print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                            eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + eDetail["threshold"])
                elif (executingStatus == 'Complete'):
                    if (shortCode == "request complete"):
                        print("\nRequest has been successfully completed.\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        releaseVariables['litmus_test_passed'] = True
                    elif (shortCode.__contains__("error")):
                        print("\nError occurred.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    elif (shortCode.__contains__("_fail")):
                        print("\nRequest failed.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    else:
                        print("\nInvalid executing state received.\n")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                else:
                    print("\nInvalid executing status received.\n")
                    print(executingStatus)
                    print("\n")
                    sys.exit(1)
                break
            if timeoutOccured:
                print("\nTimeout occurred.\n")
                sys.exit(1)
        - name: Process Basic Test Response
          type: xlrelease.ScriptTask
          precondition: "releaseVariables['litmus_process_basic'] == True"
          script: |-
            import json
            import urllib2
            import time
            import sys

            payload = {
                "requestId":${litmus_request_id}
            }

            # Send req to Litmus for status check
            data = json.dumps(payload)
            baseURL = "${litmus_test_url}"
            if not baseURL.endswith("/"):
                baseURL = baseURL + "/"
            url = baseURL + "LitmusTest/GetRequestStatus"

            timePassed = 0
            timeoutOccured = True
            while (timePassed < int(${litmus_basic_timeout})):
                time.sleep(${litmus_polling_interval})
                timePassed = timePassed + ${litmus_polling_interval}

                req = urllib2.Request(url=url, data=data)
                req.add_header("Content-Type", "application/json")
                response = urllib2.urlopen(req).read()
                message = json.loads(response)
                executingStatus = message["executingStatus"]
                returnCode = message["executingState"]
                index = returnCode.find("(")
                shortCode = returnCode
                if index != -1:
                    shortCode = returnCode[:returnCode.find("(")]
                shortCode = shortCode.lower()

                if (executingStatus == 'Basic Executing'):
                    continue
                print(message)
                print("\n")
                print("\n")
                timeoutOccured = False
                executionDetails = message["executionDetails"]
                if (executingStatus == "Regression Executing"):
                    if (shortCode == "basic_pass"):
                        print("\nBasic Passed, Regression Test is scheduled\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        releaseVariables['litmus_process_regression'] = True
                    else:
                        print("\nInvalid executing state received.\n")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                elif (executingStatus == 'Complete'):
                    if (shortCode == "request complete"):
                        print("\nRequest has been successfully completed.\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        releaseVariables['litmus_test_passed'] = True
                    elif (shortCode.__contains__("error")):
                        print("\nError occurred.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    elif (shortCode.__contains__("_fail")):
                        print("\nRequest failed.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    else:
                        print("\nInvalid executing state received.")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                else:
                    print("\nInvalid executing status received.\n")
                    print(executingStatus)
                    print("\n")
                    sys.exit(1)
                break
            if timeoutOccured:
                print("\nTimeout occurred.\n")
                sys.exit(1)
        - name: Process Regression Test Response
          type: xlrelease.ScriptTask
          precondition: "releaseVariables['litmus_process_regression'] == True"
          script: |-
            import json
            import urllib2
            import time
            import sys

            payload = {
              "requestId":${litmus_request_id}
            }

            # Send req to Litmus for status check
            data = json.dumps(payload)
            baseURL = "${litmus_test_url}"
            if not baseURL.endswith("/"):
                baseURL = baseURL +"/"
            url = baseURL+"LitmusTest/GetRequestStatus"

            timePassed = 0
            timeoutOccured = True
            while (timePassed < int(${litmus_regression_timeout})):
                time.sleep(${litmus_polling_interval})
                timePassed = timePassed+ ${litmus_polling_interval}

                req = urllib2.Request(url=url, data=data)
                req.add_header("Content-Type", "application/json")
                response = urllib2.urlopen(req).read()
                message = json.loads(response)

                executingStatus = message["executingStatus"]
                returnCode = message["executingState"]
                index = returnCode.find("(")
                shortCode = returnCode
                if index != -1:
                    shortCode = returnCode[:returnCode.find("(")]
                shortCode = shortCode.lower()
                if (executingStatus == 'Regression Executing' ):
                    continue
                print(message)
                print("\n")
                print("\n")
                timeoutOccured = False
                executionDetails = message["executionDetails"]
                if(executingStatus == 'Complete'):
                    if(shortCode == "request complete"):
                        print("\nRequest has been successfully completed.\n")
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                        releaseVariables['litmus_test_passed'] = True
                    elif(shortCode.__contains__("error")):
                        print("\nError occurred.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    elif (shortCode.__contains__("_fail")):
                        print("\nRequest failed.\n")
                        print(returnCode)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                        print("\n")
                        sys.exit(1)
                    else:
                        print("\nInvalid executing state received.")
                        print(returnCode)
                        print("\n")
                        sys.exit(1)
                else:
                    print("\nInvalid executing status received.\n")
                    print(executingStatus)
                    print("\n")
                    sys.exit(1)
                break
            if timeoutOccured:
                print("\nTimeout occurred.\n")
                sys.exit(1)
        - name: Sign off LitmusTest execution
          type: xlrelease.GateTask
          description: |-
            #### Hello Quality Engineer ${delivery_environment_type} Team :-

            Please review litmus test results and click "complete" to sign off.
          tags:
          - key_process_step
    - name: Post deployment certification by Quality Engineer PROD team
      type: xlrelease.GateTask
      description: |-
        #### Hello Quality Engineer ${delivery_environment_type} Team :-

        Can ${artifact_build_version_artifactoryUrl} be marked ${delivery_environment_name}-Certified=true in Artifactory ?

        Click "Complete" to confirm
      tags:
      - key_process_step
      conditions:
      - name: "Tests executed, results reviewed. Build looks good ! OK to certify?"
        type: xlrelease.GateCondition
    - name: Certify build artifact version (s)
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: "Mark the artifact  ${artifactoryBuildName} certified in artifactory"
        type: xlrelease.ScriptTask
        tags:
        - key_process_step
        script: |-
          ### Set Deployment Dashboard parameters

          dashboard_delivery_environment_name = "${dashboard_delivery_environment_name}"
          dashboard_certStatus = str(dashboard_delivery_environment_name) + "-certStatus"
          ######

          full_url = "${artifact_build_version_artifactoryUrl}"
          urls_list = full_url.split(",")

          for myurl in urls_list:
              api_call_url=myurl.replace("'","")
              api_call_url=api_call_url.replace("[","")
              api_call_url=api_call_url.replace("]","")
              api_call_url=api_call_url.replace(" ","")
              api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

              artifact_url_to_update=api_call_url+"?properties="+"${delivery_environment_name}"+"-Certified=Yes"
              request = HttpRequest({'url': '${global.artifactoryurl}'})
              headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
              response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
              status = response.getStatus()

              if response.getStatus() == 204:
                  releaseVariables[dashboard_certStatus] = 'Certified'
                  print myurl, " have been certified"
                  print '\n'
              else:
                  print myurl, " could not be certified"
                  sys.exit(1)
      - name: "Mark Build Number:${artifact_build_version_buildnum_var} as a Release\
          \ Candidate"
        type: xlrelease.ScriptTask
        tags:
        - key_process_step
        script: |-
          import urllib2
          import json

          artifactoryUrl="${global.artifactoryurl}/api/search/aql"

          data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
          artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
          artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
          artifactoryRequest.add_header("Content-Type", "text/plain")
          artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
          artifactData = json.loads(artifactoryResponse)
          print type(artifactData)

          #UnTag the Previous Release Candidate
          mylist=""
          for i in xrange(len(artifactData["results"])):
              for j in xrange(len(artifactData["results"][i]["properties"])):
                  if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                      artifact_url_to_update="/api/storage"+"/"+artifactData["results"][i]["repo"]+"/"+artifactData["results"][i]["path"]+"/"+artifactData["results"][i]["name"]+"?properties="+"${release_candidate_name}"+"-Certified=No"
                      request = HttpRequest({'url': '${global.artifactoryurl}'})
                      headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                      response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                      status = response.getStatus()


          #Tag the current build as Release Candidate
          full_url = "${artifact_build_version_artifactoryUrl}"
          urls_list = full_url.split(",")
          for myurl in urls_list:
              api_call_url=myurl.replace("'","")
              api_call_url=api_call_url.replace("[","")
              api_call_url=api_call_url.replace("]","")
              api_call_url=api_call_url.replace(" ","")
              api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

              artifact_url_to_update=api_call_url+"?properties="+"${release_candidate_name}"+"-Certified=Yes"
              request = HttpRequest({'url': '${global.artifactoryurl}'})
              headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
              response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
              status = response.getStatus()
              if response.getStatus() == 204:
                  print myurl, " have been certified as a Release Candidate"
                  print '\n'
              else:
                  print myurl, " could not be certified as a Release Candidate"
                  sys.exit(1)
      - name: Phase certification summary
        type: xlrelease.ScriptTask
        script: |-
          #phase_certified_artifact_version_name="phase_certified_artifact_version_"+"${component_name}"
          releaseVariables["phase_certified_artifact_version_name"] = "${artifact_build_version_artifactoryUrl}"

          #phase_certified_artifact_property_name = "phase_certified_artifact_property_"+"${component_name}"
          releaseVariables["phase_certified_artifact_property_name"] = "${delivery_environment_name}-Certified"
    - name: User story status update
      type: xlrelease.SequentialGroup
      precondition: "\"${jiraEnableStatusUpdates}\".lower() == \"yes\""
      tags:
      - key_process_step
      tasks:
      - name: Confirm FixVersion and credentials for JIRA
        type: xlrelease.UserInputTask
        description: Please enter the required information below.
        tags:
        - key_process_step
        variables:
        - jira_fixversion
        - jiraUserId
        - jiraUserPassword
      - name: Get list of user stories associated with this release
        type: jira.Query
        username: "${jiraUserId}"
        query: "project = \"${jira_project}\" AND issuetype = Story AND fixVersion\
          \ = \"${jira_fixversion}\""
        variableMapping:
          pythonScript.password: "${jiraUserPassword}"
          pythonScript.issues: "${user_stories_list}"
      - name: Get list of user stories associated with this release that are currently
          in "READY TO RELEASE" status
        type: jira.Query
        username: "${jiraUserId}"
        query: "project = \"${jira_project}\" AND issuetype = Story AND fixVersion\
          \ = \"${jira_fixversion}\" AND status = \"Ready to Release\""
        variableMapping:
          pythonScript.issues: "${ready_to_release_user_stories}"
          pythonScript.password: "${jiraUserPassword}"
      - name: Confirm the list of stories whose status needs to be updated to "RELEASED"
        type: xlrelease.UserInputTask
        description: "#### Confirm if the list of stories below can be updated to\
          \ \"RELEASED\" state ####"
        tags:
        - key_process_step
        variables:
        - user_stories_list
        - ready_to_release_user_stories
      - name: Construct Jira URL
        type: xlrelease.ScriptTask
        script: |-
          jira_stories = ${user_stories_list}

          url_list = ""

          for story in jira_stories:
              construct_url = "${global.jiraurl}/browse/" + story
              url_list = url_list + "\n\n" + construct_url

          print url_list
          releaseVariables['fixversion_stories_jira_url'] = url_list
      - name: Update status of confirmed user stories to "RELEASED"
        type: jira.UpdateIssues
        username: "${jiraUserId}"
        newStatus: RELEASED
        comment: "Released via ITSM change ${target_release_crq_number}"
        variableMapping:
          pythonScript.password: "${jiraUserPassword}"
          pythonScript.issues: "${user_stories_list}"
    - name: Closure
      type: xlrelease.SequentialGroup
      tags:
      - key_process_step
      tasks:
      - name: "Update ${target_release_crq_number} work info w/ delivery pipeline\
          \ status"
        type: xlrelease.ScriptTask
        precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
        script: |-
          import urllib2
          import json
          import time
          import base64

          url="${global.remedyurl}/security/issueToken?servicename=changeservice"

          req=urllib2.Request(url=url,data="")

          req.add_header("Content-Type", "application/x-www-form-urlencoded")
          req.add_header("userName", "ZS30SW4")
          req.add_header("password", base64.b64decode("cndralMyWXE="))

          Token=urllib2.urlopen(req).read()
          #releaseVariables["muleToken"]=Token


          # defining the api-endpoint
          url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


          transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

          transId ="XLR_Add_Worklog_"+str(transaction_datetime)

          # sourceReqId is obtained from Remedy (its constant and wont change for every call)
          #sourceReqId = 'XLR_GWB_CHANGE_002'

          print("transaction ID:", transId)

          json1={
              "transactionDetails": {
              "transactionType": "ADDWORKLOG",
              "transactionId": transId,
              "eventSource": "XLR_GWB_CHANGE",
              "sourceRequestId": "XLR_GWB_CHANGE",
              "eventTarget": "BAC_CHANGE",
              "targetRequestId": "${target_release_crq_number}",
              "transactionDate": transaction_datetime
            },
            "updateSystemManaged": {
              "personIdType": "LoginName",
              "createdBy": "${xlr_remedy_workinfo_creator}"
            },
            "changeWorkInfo": {
              "workLogId": "",
              "workLogType": "General Information",
              "workLogNotes": """${spkName} ${component_name} has been successfully deployed, tested & certified in Production environment  \n\n Deployed artifacts:  ${artifact_build_version_artifactorybrowseUrl} \n\n Released User Stories: ${fixversion_stories_jira_url}  \n\n For further details on this release, check delivery pipeline ${delivery_pipeline_url}""",
              "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
              "workLogAccess": "Public"
             }
          }

          print(json1)

          # data to be sent to api
          data=json.dumps(json1)

          req1=urllib2.Request(url=url2,data=data)

          req1.add_header("Authorization", Token)
          req1.add_header("Content-Type", "application/json")
          req1.get_method = lambda : 'PUT'

          response=urllib2.urlopen(req1).read()
          message = json.loads(response)
          print(message)
      - name: Update release name
        type: xlrelease.ScriptTask
        script: |-
          current_release = getCurrentRelease()

          current_release.title = "{0} - {1}".format(current_release.title,"${target_release_crq_number}")
          current_release.description = "${spkName} ${component_name} has been successfully deployed, tested & certified in DEV & LLE environments  \n\nDeployed artifacts:  ${artifact_build_version_artifactorybrowseUrl} \n\nFor further details on this release, check delivery pipeline ${delivery_pipeline_url}"


          releaseApi.updateRelease(current_release)
      - name: Compile Email Notification
        type: xlrelease.ScriptTask
        script: |-
          releaseVariables["email_body"] = "${spkName} ${component_name} has been successfully"
          releaseVariables["email_body_content"] =""
          releaseVariables['jira'] = ""
          phase_Title = getCurrentPhase().getTitle()
          release_Id = getCurrentRelease().getId()
          print ("phase_Title===", phase_Title)
          print("release_Id===", release_Id)

          deploy = getTasksByTitle("Deploy ${artifactoryBuildName}", phaseTitle = phase_Title, releaseId = release_Id)
          litmus = getTasksByTitle("Sign off LitmusTest execution", phaseTitle = phase_Title, releaseId = release_Id)
          cert = getTasksByTitle("Post deployment certification by Quality Engineer PROD team", phaseTitle = phase_Title, releaseId = release_Id)
          jira = getTasksByTitle('Update status of confirmed user stories to "RELEASED"', phaseTitle = phase_Title, releaseId = release_Id)
          if len(deploy) != 0 and deploy[0]['status'] == "COMPLETED":
              releaseVariables["email_body"] = releaseVariables["email_body"]+" deployed "
              releaseVariables["email_body_content"] = "- #### Deployed artifacts: \n ${artifact_build_version_artifactorybrowseUrl} \n" + "- #### Refer the below url for tower job details: \n ${ansible_tower_job_url}"
          if len(litmus)!=0 and litmus[0]['status'] == "COMPLETED":
              releaseVariables["email_body"] = releaseVariables["email_body"]+", litmus test executed "
          if len(cert)!=0 and cert[0]['status'] == "COMPLETED":
             releaseVariables["email_body"] = releaseVariables["email_body"]+"& certified"
          if jira[0]['status']=="COMPLETED":
              releaseVariables['jira'] = """- #### Released user stories: \n ${fixversion_stories_jira_url}"""

          if deploy[0]['status'] =="SKIPPED" and litmus[0]['status']=="SKIPPED" and cert[0]['status'] == "SKIPPED":
              releaseVariables["email_body"] ="Deployment, Litmus test execution and certification of ${spkName} ${component_name} has been skipped"
          releaseVariables["email_body"] = releaseVariables["email_body"]+" in ${delivery_environment_name}"
          releaseVariables['prod_crq'] = """- #### Production change record:  [${target_release_crq_number}](${global.itsmurl}${target_release_crq_number}) \n\n"""
          print("Deploy status ==", deploy[0]['status'])
          print ("Cert status ===", cert[0]['status'])
          print("JIRA Status==",jira[0]['status'])
          print("Litmus status ==", litmus[0]['status'])
          print(releaseVariables["email_body"])
      - name: Send release notification
        type: xlrelease.NotificationTask
        description: "#### Send email notification for ${delivery_environment_name}\
          \ release ####"
        tags:
        - key_process_step
        addresses:
        - "${release_notification_list}"
        subject: "${spkName} ${component_name} release to ${delivery_environment_name}\
          \ - ${target_release_crq_number}"
        body: |-
          #### ${email_body}

          ${prod_crq}

          ${email_body_content}

          ${jira}

          - #### Refer release pipeline below for more info via 2 available options (flow view , table view):
          ${delivery_pipeline_url}
    - name: Approval from Integrated Release
      type: xlrelease.GateTask
      description: "The gate will be approved by ${integrated_release_name}"
      owner: script_runner
      plannedDuration: 349200
      precondition: getCurrentRelease().title.startswith("Integrated")
      tags:
      - key_process_step
    color: '#009CDB'
  variables:
  - type: xlrelease.StringVariable
    key: MANUAL-DATA-ENTRY_SECTION_START
    requiresValue: false
    value: "###############  MANUAL ENTRY ###############"
  - type: xlrelease.StringVariable
    key: releaseConfigFileRepoLocation
    requiresValue: false
    description: Format SPK@repo_name@branch_name@releaseconfigfile_name
    value: HZCD@xlr_universal_template@feature/HZCD-1018-sample-template-for-releaseconfigfile@releaseconfigfile_newformat.json
  - type: xlrelease.PasswordStringVariable
    key: towerDeployerPasswordNonProd
    requiresValue: false
    description: Password of the deployer id that has permissions to execute your
      component's deployment job template
  - type: xlrelease.PasswordStringVariable
    key: towerDeployerPasswordProd
    requiresValue: false
    description: Password of the deployer id that has permissions to execute your
      component's deployment job template
  - type: xlrelease.StringVariable
    key: MANUAL-ENTRY-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: PROVISIONED-BY-RELEASECONFIG_FILE-START
    requiresValue: false
    value: "###### PROVISIONED BY RELEASECONFIG FILE ######"
  - type: xlrelease.StringVariable
    key: ENV-SECTION-START
    requiresValue: false
    value: "####### ENVIRONMENT METADATA #########"
  - type: xlrelease.StringVariable
    key: spkName
    requiresValue: false
    description: "What's your SPK name? (This will be used as tags for reporting)\
      \ [e.g RPIST]"
    value: ETASC
  - type: xlrelease.StringVariable
    key: lobName
    requiresValue: false
    description: "What's your LOB name? (This will be used as tags for reporting)\
      \ [e.g GBAM or CSWT or CDO]"
  - type: xlrelease.ListStringVariable
    key: spkComponentsToRelease
    requiresValue: false
    description: "[WHAT TO RELEASE] - Component Name is your Bitbucket Repo Name (a\
      \ buildable unit) which has a corresponding Jenkins build job"
    value:
    - dee_poc_delivery
  - type: xlrelease.ListStringVariable
    key: releaseEnvironments
    requiresValue: false
    description: "[WHERE TO RELEASE] - List of environments that the components will\
      \ be deployed too  (e.g Dev,DIT,CIT,SIT,UAT,PreProd,Prod etc). Keep the names\
      \ same as the ones you'd use in your ansible playbooks. Ensure entries are in\
      \ the order of their execution"
  - type: xlrelease.MapStringStringVariable
    key: phaseType
    requiresValue: false
    description: "Map your environments names i.e., for each of the environment defined\
      \ in the \"releaseEnvironments\" variable to their types (options are: DEV,\
      \ LLE or PROD). Based on environment type, gate approvers will be automatically\
      \ assigned to their respective Deployer & Quality Engineer teams.  Here the\
      \ release environment name as defined in \"releaseEnvironments\" variable is\
      \ the Key and the value is either DEV, LLE or PROD. For ex: SIT will be mapped\
      \ to DEV, UAT to LLE and PROD to PROD. (keep them same, case sensitive)"
  - type: xlrelease.StringVariable
    key: ENV-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: TOWER-SECTION-START
    requiresValue: false
    value: "############## ANSIBLE TOWER ###########"
  - type: xlrelease.MapStringStringVariable
    key: towerJobTemplate
    requiresValue: false
    description: "Names of Ansible deployment job template for each one of the environment\
      \ defined in the variable \"releaseEnvironments.\" Enter it in key-value pair\
      \ with key being the environment name as entered in the \"releaseEnvironments\"\
      \ variable and value being ansible job deployment. (keep them same, case sensitive)\
      \ and value being the comma separated list for all the components in the same\
      \ order as mentioned in the above fields. Please ensure key-value entries for\
      \ all the envs setup in this template"
  - type: xlrelease.MapStringStringVariable
    key: towerInventory
    requiresValue: false
    description: "Names of Ansible inventory for each one of the environment defined\
      \ in the variable \"releaseEnvironments.\" Enter it in key-value pair with key\
      \ being the environment name as entered in the \"releaseEnvironments\" variable\
      \ and value being ansible inventory name. (keep them same, case sensitive).\
      \ You can leave blank for the value if you dont want provide inventory name\
      \ but Key should be mandatory."
  - type: xlrelease.StringVariable
    key: towerDeployerIdNonProd
    requiresValue: false
    description: Deployer id that has permissions to execute the components deployment
      job templates in tower. Leave it blank if you want to type it in at run time.
      This value can be overwritten at run time
  - type: xlrelease.StringVariable
    key: towerDeployerIdProd
    requiresValue: false
    description: Deployer id that has permissions to execute the components deployment
      Prod job templates in tower. Leave it blank if you want to type it in at run
      time. This value can be overwritten at run time
  - type: xlrelease.MapStringStringVariable
    key: towerAnsibleExtras
    requiresValue: false
    description: "Do you have extra vars w/ static values for every env? If yes, type\
      \ them in here in key-value format. Key is extra var name, value is its value"
  - type: xlrelease.StringVariable
    key: TOWER-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: ARTIFACTORY-SECTION-START
    requiresValue: false
    value: "############# ARTIFACTORY #############"
  - type: xlrelease.StringVariable
    key: artifactoryBuildName
    requiresValue: false
    description: "Enter the corresponding artifactory build name for the component.\
      \ Eg. ETASC :: dee_poc_delivery :: release :: runit-release-2.0"
    value: "ETASC :: dee_poc_delivery :: release :: runit-release-2.0"
  - type: xlrelease.StringVariable
    key: artifactoryBuildRepo
    requiresValue: false
    description: "Enter the repository location where the build artifacts are stored\
      \ in artifactory.  Eg: libs-release-local-maven"
  - type: xlrelease.StringVariable
    key: ARTIFACTORY-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: EMAIL-SECTION-START
    requiresValue: false
    value: "##### EMAIL NOTIFICATION LISTS #############"
  - type: xlrelease.StringVariable
    key: phaseNotificationDg_dev
    requiresValue: false
    description: "comma seperated email ids for DEV release notifications (Eg user@domain.com,\
      \ user@domain.com)"
  - type: xlrelease.StringVariable
    key: phaseNotificationDg_lle
    requiresValue: false
    description: "comma separated email ids/DG for LLE release notifications  (Eg user@domain.com,\
      \ user@domain.com)"
  - type: xlrelease.StringVariable
    key: phaseNotificationDg_prod
    requiresValue: false
    description: "comma separated email ids/DG for PROD release notifications (Eg user@domain.com,\
      \ user@domain.com)"
  - type: xlrelease.StringVariable
    key: EMAIL-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: GATES-SECTION-START
    requiresValue: false
    value: "########## DEPLOYMENT GATES ###########"
  - type: xlrelease.StringVariable
    key: phaseEnablePreDeployGate_dev
    requiresValue: false
    description: Do you want to have a gate assigned to "Deployer DEV" team to approve
      before triggering DEV deployments in the release flow
    valueProvider:
      type: xlrelease.ListOfStringValueProviderConfiguration
      values:
      - "Yes"
      - "No"
  - type: xlrelease.StringVariable
    key: phaseEnablePostDeployGate_dev
    requiresValue: false
    description: Do you want to have a gate assigned to "Quality Engineer DEV" team
      to approve and sign off on DEV deployments?
    valueProvider:
      type: xlrelease.ListOfStringValueProviderConfiguration
      values:
      - "Yes"
      - "No"
  - type: xlrelease.StringVariable
    key: phaseEnablePreDeployGate_lle
    requiresValue: false
    description: Do you want to have a gate assigned to "Deployer LLE" team to approve
      before triggering LLE deployments in the release flow
    valueProvider:
      type: xlrelease.ListOfStringValueProviderConfiguration
      values:
      - "Yes"
      - "No"
  - type: xlrelease.StringVariable
    key: phaseEnablePostDeployGate_lle
    requiresValue: false
    description: Do you want to have a gate assigned to "Quality Engineer LLE" team
      to approve and sign off on LLE deployments?
    valueProvider:
      type: xlrelease.ListOfStringValueProviderConfiguration
      values:
      - "Yes"
      - "No"
  - type: xlrelease.StringVariable
    key: GATES-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: JIRA-SECTION-START
    requiresValue: false
    value: "################# JIRA #################"
  - type: xlrelease.StringVariable
    key: jiraEnableStatusUpdates
    requiresValue: false
    description: "set it to yes if you want to enable steps to auto update jira story\
      \ status during production release. If set to true, fill in 4 questions that\
      \ follows next else keep them blank or NA"
    valueProvider:
      type: xlrelease.ListOfStringValueProviderConfiguration
      values:
      - "Yes"
      - "No"
  - type: xlrelease.StringVariable
    key: jiraUserId
    requiresValue: false
    description: User ID that can query your JIRA project and update story status
  - type: xlrelease.PasswordStringVariable
    key: jiraUserPassword
    requiresValue: false
    description: Password associated with that user ID that can query your JIRA project
      and update story status
  - type: xlrelease.StringVariable
    key: JIRA-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: REMEDY-SECTION-START
    requiresValue: false
    value: "############# REMEDY ITSM #############"
  - type: xlrelease.StringVariable
    key: remedyEnableIntegration
    requiresValue: false
    description: "Please select true if you want to enable tasks in this XLR template\
      \ that would auto query/update CRQ [NOTE: This functionality is not available\
      \ for Remedy Production instance. All the values in the variables below prefixed\
      \ as xlr are for demo purposes only]"
    valueProvider:
      type: xlrelease.ListOfStringValueProviderConfiguration
      values:
      - "Yes"
      - "No"
  - type: xlrelease.StringVariable
    key: REMEDY-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: LITMUS-SECTION-START
    requiresValue: false
    value: "############## LITMUS  ################"
  - type: xlrelease.MapStringStringVariable
    key: litmusEnableFunctionalTests
    requiresValue: false
    description: "Do you want to enable/disable automated tests in each your envs?\
      \ Enter it in key-value pair w/ key being the environment name as entered in\
      \ the prior variable (keep them same, case sensitive). To enable automated test\
      \ cases, value will be 'Yes', otherwise test cases will be disabled. By default\
      \ automated test cases are disabled."
  - type: xlrelease.MapStringStringVariable
    key: litmusComponentName
    requiresValue: false
    description: "What are the names of LitmusTest components for each one of your\
      \ envs? Enter it in key-value pair w/ key being the environment name as entered\
      \ in the prior variable (keep them same, case sensitive). Please ensure key-value\
      \ entries for all the envs setup in this template"
  - type: xlrelease.MapStringStringVariable
    key: litmusTargetApplicationUrl
    requiresValue: false
    description: "What are the URLs of LitmusTest rest endpoint for each one of your\
      \ envs? Enter it in key-value pair w/ key being the environment name as entered\
      \ in the prior variable (keep them same, case sensitive). Please ensure key-value\
      \ entries for all the envs setup in this template"
  - type: xlrelease.StringVariable
    key: LITMUS-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: SONAR-SECTION-START
    requiresValue: false
    value: "################# SONAR ##############"
  - type: xlrelease.MapStringStringVariable
    key: sonarEnableMetricsCheck
    requiresValue: false
    description: "Where do you want a gate for sonar metrics check in the release\
      \ flow? If yes, fill in the sonar section variables below"
  - type: xlrelease.StringVariable
    key: sonarComponentKey
    requiresValue: false
    description: "Please provide the Sonar Project Key from the Sonar properties file\
      \ , example: INC-source-44849"
  - type: xlrelease.StringVariable
    key: SONAR-SECTION-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: DEFAULT-VALUES-START
    requiresValue: false
    value: '#############DEFAULT VALUES#############'
  - type: xlrelease.StringVariable
    key: osPlatform
    requiresValue: false
    description: "This variable is needed as part of mandatory Matrix adoption. Select\
      \ application OS platform. Ex: Linux/windows"
    value: Linux
  - type: xlrelease.StringVariable
    key: target_release_crq_number
    requiresValue: false
    description: Please enter the valid CRQ number (e.g CRQ000001607133)
  - type: xlrelease.StringVariable
    key: integrated_release_name
    requiresValue: false
    description: Please Do Not Configure this value
  - type: xlrelease.StringVariable
    key: DEFAULT-VALUES-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: PROVSIONED-BY-RELEASECONFIG_FILE-END
    requiresValue: false
    value: '######################################'
  - type: xlrelease.StringVariable
    key: xlr_remedy_workinfo_creator
    requiresValue: false
    showOnReleaseStart: false
    description: This is the nbk-id of the user who creates the worklog of CRQ in
      Remedy. The value of this variable auto set during the execution of the release.
  - type: xlrelease.StringVariable
    key: xlr_remedy_workinfo_workLogSubmitter
    requiresValue: false
    showOnReleaseStart: false
    description: This is the nbk-id of the user who submits the worklog of CRQ in
      Remedy. The value of this variable auto set during the execution of the release.
  - type: xlrelease.StringVariable
    key: ArtifactoryAPIkey
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: CurrentArtifactoryAPIkey
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifact_build_version_var
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifact_build_version_path_var
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: delivery_environment_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: jira_fixversion
    requiresValue: false
    showOnReleaseStart: false
    description: What's the value of FixVersion (release name) in your JIRA project
      for this production release?
  - type: xlrelease.MapStringStringVariable
    key: user_stories_list
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifact_build_version_repo_var
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: delivery_environment_type
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: component_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: litmus_polling_interval
    requiresValue: false
    showOnReleaseStart: false
    description: "This is time in Seconds, between two successive 'status check' calls\
      \ to LitmusTest.[e.g. 300]. Default value is 300."
    value: "300"
  - type: xlrelease.StringVariable
    key: ansible_tower_job_template_id
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifact_build_version_artifactoryUrl
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: litmus_spk
    requiresValue: false
    showOnReleaseStart: false
    description: What's the SPK associated with the Litmustest this template intends
      to execute?
  - type: xlrelease.StringVariable
    key: ansible_tower_job_template_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: release_notification_list
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: CRQStatus
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: litmus_phase
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: litmus_enable_automated_tests
    requiresValue: false
    showOnReleaseStart: false
    description: yes/no
  - type: xlrelease.StringVariable
    key: phase_certified_artifact_property
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: phase_certified_artifact_version
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: delivery_pipeline_url
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.MapStringStringVariable
    key: ready_to_release_user_stories
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: enable_sonar_metrics_check
    requiresValue: false
    showOnReleaseStart: false
    description: The value of this variable will be auto set based on the sonarEnableMetricsCheck
      value
    valueProvider:
      type: xlrelease.ListOfStringValueProviderConfiguration
      values:
      - "Yes"
      - "No"
  - type: xlrelease.StringVariable
    key: SonarQube_token
    requiresValue: false
    showOnReleaseStart: false
    description: This is auto generated by XLR
  - type: xlrelease.StringVariable
    key: sonarqube_blocker_violations
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: sonarqube_bugs
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: sonarqube_code_smells
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: sonarqube_critical_violations
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: sonarqube_duplicated_blocks
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: sonarqube_duplicated_lines_density
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: sonarqube_ncloc
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: sonarqube_quality_gate
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: sonarqube_vulnerabilities
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: fixversion_stories_jira_url
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifact_build_version_artifactorybrowseUrl
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifact_build_version_ait_var
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifact_build_version_scmloc_var
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: release_owner
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifact_build_version_buildnum_var
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifact_build_version_ciurl_var
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.MapStringStringVariable
    key: litmus_env_to_app_url_mapping
    requiresValue: false
    showOnReleaseStart: false
    description: "What are the URLs of application you want LitmusTest to use to run\
      \ the test cases for each one of your envs? Enter it in key-value pair w/ key\
      \ being the environment name as entered in the prior variable (keep them same,\
      \ case sensitive). Please ensure key-value entries for all the envs setup in\
      \ this template"
  - type: xlrelease.StringVariable
    key: artifact_build_version_scmbranch_var
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: litmus_test_url
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.BooleanVariable
    key: req_submitted
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: litmus_request_id
    requiresValue: false
    showOnReleaseStart: false
    description: requestId returned by Litmus
  - type: xlrelease.BooleanVariable
    key: litmus_test_passed
    requiresValue: false
    showOnReleaseStart: false
    label: Tells the result of Litmus test execution
  - type: xlrelease.BooleanVariable
    key: litmus_process_basic
    requiresValue: false
    showOnReleaseStart: false
    label: Tells if Basic test should be executed or not
  - type: xlrelease.StringVariable
    key: litmus_test_component
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.BooleanVariable
    key: litmus_input_validated
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.BooleanVariable
    key: litmus_process_regression
    requiresValue: false
    showOnReleaseStart: false
    label: Tells if regression test result task should be processed or not
  - type: xlrelease.StringVariable
    key: litmus_basic_timeout
    requiresValue: false
    showOnReleaseStart: false
    value: "5400"
  - type: xlrelease.StringVariable
    key: litmus_regression_timeout
    requiresValue: false
    showOnReleaseStart: false
    value: "14400"
  - type: xlrelease.StringVariable
    key: litmus_smoke_timeout
    requiresValue: false
    showOnReleaseStart: false
    value: "1200"
  - type: xlrelease.StringVariable
    key: litmus_app_url
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: phase_certified_artifact_property_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: phase_certified_artifact_version_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: nonprod_tower_deployer_id
    showOnReleaseStart: false
  - type: xlrelease.PasswordStringVariable
    key: nonprod_tower_deployer_password
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: jira_project
    requiresValue: false
    showOnReleaseStart: false
    description: What's your JIRA project name? (This should be same as SPK name)
  - type: xlrelease.MapStringStringVariable
    key: litmus_env_to_phase_mapping
    requiresValue: false
    showOnReleaseStart: false
    description: "What are the names of test phase for each one of your envs? Enter\
      \ it in key-value pair w/ key being the environment name as entered in the prior\
      \ variable (keep them same, case sensitive). Please ensure key-value entries\
      \ for all the envs setup in this template"
  - type: xlrelease.StringVariable
    key: jenkinsTriggerInfo
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: grm_record_code
    requiresValue: false
    showOnReleaseStart: false
    value: BEN-04-05
  - type: xlrelease.StringVariable
    key: grm_record_jurisdiction
    requiresValue: false
    showOnReleaseStart: false
    value: US
  - type: xlrelease.StringVariable
    key: auto_refresh_test
    requiresValue: false
    showOnReleaseStart: false
    value: "123"
  - type: xlrelease.StringVariable
    key: master_template_version
    requiresValue: false
    showOnReleaseStart: false
    description: "This variable used to identify the master template version for Auto\
      \ Refresh Utility, so don't delete it"
    value: "Universal release template (release branch)  version 2.0 Production date\
      \ : 03/09/19"
  - type: xlrelease.StringVariable
    key: artifact_build_name_url_format
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: old_artifact_build_version_artifactoryUrl
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: old_artifact_build_version_buildnum_var
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: original_release_title
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: dashboard_delivery_environment_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: email_body_content
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: email_body
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: jira
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: release_candidate_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: artifactory_certification_history
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: release_config_file_repo_url
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: prod_crq
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: ansible_tower_job_inventory_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: ansible_tower_job_inventory
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: ansible_tower_instance_group
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.IntegerVariable
    key: ansible_tower_job_inventory_id
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: published_artifact_url
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: repo_user
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: ansible_template_inventory_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: tower_job_inventory_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: ansible_tower_job_template_instance_group_url
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: ansible_tower_instance_group_from_template
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: xlr_inventory_name
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.ListStringVariable
    key: temp_integrated_release_environment
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: ansible_job_id
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: ansible_tower_job_url
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: jenkinsBuildNo
    requiresValue: false
    showOnReleaseStart: false
  - type: xlrelease.StringVariable
    key: release_config_file_content
    requiresValue: false
    showOnReleaseStart: false
  allowConcurrentReleasesFromTrigger: false
  riskProfile: Default risk profile
